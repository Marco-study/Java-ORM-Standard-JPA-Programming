# 5장 연관관계 매핑 기초

ORM에서 가장 어려운 부분이 객체 연관관계와 테이블 연관관계를 매핑하는 일이다.

**객체의 참조와 테이블의 외래 키를 매핑하는 것**이 이 장의 목표다.

연관관계 매핑을 이해하기 위한 핵심 키워드를 알아보자.

- **방향** : [단방향, 양방향] 존재 → 한 쪽만 참조하는 것 = 단방향, 양쪽 다 참조하는 것 = 양방향.
- **다중성** : [다대일, 일대다, 일대일, 다대다] 존재 → 팀과 회원의 관계에서 여러 회원이 하나의 팀에 존재할 수 있기에 회원-팀 = 다대일, 하나의 팀에 여러 회원이 존재할 수 있기에 팀-회원 = 일대다
- **연관관계의 주인** : **양방향 연관관계**로 만들면 **연관관계의 주인**을 정해야함.

## 단방향 연관관계

회원과 팀을 예시 → 회원 : 팀 = 다대일 관계

```java
class User {
	Team team;
}

---

class Team {
}
```

위와 같은 객체에서의 연관관계는 단방향으로만 이루어짐. 

테이블에서는 외래키를 이용하면 무조건 양방향이다 양쪽 어떤 테이블에서도 JOIN 할 수 있기 때문.

그래서 객체에서 이 양방향 연관관계를 흉내내기 위해선 `Team` 에서 `User` 를 참조하면 양방향을 흉내내는 2개의 단방향 연관관계를 가질 수 있다.

**객체에서 참조를 통해 연관관계를 탐색**할 수 있는데 이를 **객체 그래프 탐색**이라고 한다.

객체에서는 연관관계를 표현하기 위해서 참조를 사용하고 테이블에서는 JOIN을 사용하는데 JPA에서는 이를 매핑해주고 이를 연관관계 매핑이라고 한다. JPA에서 어떻게 연관관계를 매핑해줄 수 있는지 알아보자.

### @JoinColumn

이는 외래 키를 매핑할 때 사용되는 어노테이션.

- 주요 속성
    - name = 매핑할 외래 키 이름을 의미하고 기본값은 “필드명_참조하는 테이블의 기본 키 컬럼명”
    - referencedColumnName = 외래 키가 참조하는 대상 테이블의 컬럼명, 기본값은 참조하는 테이블의 기본키 컬럼명.
    - foreignKey(DDL) : 외래 키 제약조건 지정, 테이블 생성시에만 사용됨.
    - 나머지는 @Column과 같다.

### @ManyToOne

다대일 관계 매핑 시 사용되는 어노테이션.

- 주요 속성
    - optional = false로 설정 시 연관된 엔티티가 항상 존재해야함, 기본값은 true
    - fetch = 글로벌 페치 전략 설정, 기본값은 FetchType.EAGER
    - casacade = 영속성 전이 기능 사용
    - targerEntity = 거의 사용하지 않지만 연관된 엔티티의 타입 정보를 설정.

# 연관관계 사용

연관관계 CRUD를 통해 어떻게 사용하는지 확인.

## 1. 저장

```java
public void testSave() {
	member1.setTeam(team1);
	em.persist(member1);
}
```

`team1` 과의 연관관계를 설정하고 `persist` 를 통해 저장하는 모습이다.

## 2. 조회

연관관계가 있는 엔티티를 조회하는 방법은 크게 2가지이다.

- 객체 그래프 탐색
    - 객체를 통해 연관된 엔티티를 조회하는 것.
- 객체지향 쿼리 사용 (JPQL)
    - 객체지향 쿼리인 JPQL을 이용하는 것. (SQL보다 간결함.)
    
    ```java
    select m from Member m join m.team t where t.name=:teamName
    ```
    
    ⇒ 회원이 팀과 관계를 가지고 있는 필드인 team을 통해서 Member와  Team을 조인했음.
    
    ⇒ 그리고 where 절을 보면 t.name을 검색조건으로 팀1에 속한 회원만 검색.
    

## 3. 수정

앞에서 말했던 것 처럼 엔티티 매니저에는 update와 같은 메소드가 없고 이를 수정하려면 dirty checking을 이용하면 됨.

```java
public void testUpdate() {
	member1.setTeam(team1);
}
```

## 4. 연관관계 제거

회원이 아무 팀에도 속하지 않게 연관관계를 제거하려면 어떻게 하면 좋을까?

```java
public void testDeleteRelation() {
	member1.setTeam(null);
}
```

## 5. 연관된 엔티티 삭제

연관된 엔티티를 삭제하고 할 때 기존에 있던 연관관계를 먼저 제거하고 삭제해야함.

안그러면 키 제약조건으로 DB에서 오류가 발생함.

# 연관관계의 주인

mappedBy 속성은 왜 필요할까? @OneToMany만 있으면 되는거 아녀?
엄밀히 객체에서 양방향 참조? → 없음.

그래서 결국 2개의 단방향 참조를 만드는데 두 객체 연관관계 중 하나를 정해서 테이블 외래 키를 관리해야한다. ⇒ 이를 `**연관관계의 주인**`이라고 한다.

## 양방향 매핑의 규칙: 연관관계의 주인

연관관계의 주인만이 DB 연관관계와 매핑되고 외래 키를 CRUD할 수 있다. 반면 주인이 아닌 쪽은 읽기만 가능.

- `주인`: mappedBy 속성 사용 X
- `주인 X`: mappedBy 속성 → 연관관계 주인 지정.

`**연관관계 주인 정하기**` == `**외래 키 관리자 선택하기**`

```java
class Member {
	@ManyToOne
	@JoinColumn(name="TEAM_ID")
	private Team team;
}

class Team {
	@OneToMany
	private List<Member> members = new ArrayList<Member>();
}
```

멤버의 team 필드를 연관관계 주인으로 설정하면 자기 테이블에 있는 FK를 관리하면 도미.

이 상황에서 멤버의 team 필드를 연관관계 주인으로 설정하지 않고 팀의 members 필드를 연관관계 주인으로 설정시 물리적으로 전혀 다른 테이블의 외래 키를 관리 ⇒ 팀의 members가 있는 팀 엔티티는 Team 테이블에 매핑되어있는데 관리해야할 외래 키는 멤버 테이블에 존재하게 된다.

## 연관관계의 주인: 외래 키가 있는곳

연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야함. 여기선 멤버 테이블이 외래키를 가져 멤버 테이블의 팀 필드가 주인이 된다.

정리하여 연관관계의 주인만 DB 연관관계와 매핑되고 외래 키를 관리할 수 있음.

주인이 아닌 반대편은 읽기만 가능하고 외래키를 변경하지는 못함.

# 양방향 연관관계 저장

양방향 연관관계는 연관관계 주인이 외래 키를 관리 → 주인이 아닌 방향은 값 설정 X

⇒ 그래도 DB에 정상 입력됨.

## 양방향 연관관계 주의점

가장 흔히 하는 실수 = 연관관계 주인이 아닌 곳에서 값을 입력하고 주인에서는 값을 입력하지 않는 경우.

⇒ 값이 정상적으로 DB에 저장되지 않는 다면 이것부터 의심하자.

## 순수한 객체까지 고려한 양방향 연관관계

위에서 말했듯 정말 연관관계 주인에서만 값을 저장하면 문제가 없을까? 물론 DB 상에 반영되는 부분에서는 문제가 전혀 없다. 하지만 POJO로 생각을 했을때 심각한 문제가 발생할 수 있다.

ORM은 객체와 RDB 모두 중요해서 두 관점을 다 생각해줘야한다. POJO로 생각했을 때 주인쪽에서만 연관관계를 설정하고 반대 방향을 설정안한 것이다. 멤버에서는 팀을 세팅했지만 팀에서는 멤버를 세팅하지 않은 것이다. 그러면 팀 객체에서 멤버가 몇 명인지 확인하면 0이 나온다.

그래서 **양방향은 양쪽 다 관계를 설정**해야한다. → 객체, RDB 관점을 모두 성립하기 위해서.

```java
public void testRelation() {
	member.setTeam(team);
	team.getMembers().add(member);
}
```

⇒ 이렇게 양쪽 관계를 다 설정해야 객체, RDB 관점에서 모두 성립하게 만들 수 있다.

## 연관관계 편의 메소드

위에서 보여준 것처럼 양방향에서 모두 관계를 설정하다가 실수로 한쪽을 못하게 되면 큰 문제로 이어질 수 있어서 이를 하나로 묶어서 **간편하게 양방향 연관관계를 설정하는 메소드를 연관관계 편의 메소**드라고 한다.

위의 testRelation이란 메소드가 연관관계 편의 메소드가 될 수 있다.

### 연관관계 편의 메소드

문제가 될 수 있는 부분은 위와 같이 연관관계 편의 메소드를 만들면 이전 관계를 끊어주지 않는다는 것이다.

```java
// member가 원래 team1에 속해있다고 가정하고

member.setTeam(team2);
team2.getMembers().addMember(member);
```

이런식으로 구현하면 team1에서 member 조회해도 찾을 수 있다. 즉 이전 관계가 끊어지지 않은 것이다.

그래서 이전관계를 아래와 같이 끊어줘야한다.

```java
public void test(Team team) {
	if (Objects.nonNull(this.team) {
		this.team.getMembers().remove(this);
	}

	this.team = team;
	team.getMembers().add(this);
}
```

⇒ 객체에서 양방향을 사용하려면 **로직을 견고하게 작성**해야한다.
