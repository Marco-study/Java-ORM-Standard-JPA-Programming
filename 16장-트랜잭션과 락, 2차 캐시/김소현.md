# 16. 트랜잭션과 락, 2차 캐시

## 16.1 트랜잭션과 락

<aside>
💡 **트랜잭션** 기초와 JPA가 제공하는 **낙관적 락과 비관적 락**에 대해 알아본다.

</aside>

### 16.1.1 트랜잭션과 격리 수준

> 트랜잭션은 **ACID**를 보장해야 한다.
> 

`**A`tomicity(원자성)**

: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다.

`**C`onsistency(일관성)**

: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.

`**I`solation(격리성)**

: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.

`**D`urability(지속성)**

: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 로그 등을 사용해서 성공한 트랜잭션 내용을 복구할 수 있어야 한다.

> 트랜잭션 **격리 수준**을 4단계로 나누어 정의한다.
> 

**READ UNCOMMITED (커밋되지 않은 읽기)**

- `DIARY READ` 문제가 발생할 수 있다.
    
    → 트랜잭션1이 데이터를 수정하고 있는데 커밋하지 않아도 트랜잭션2가 수정 중인 데이터를 조회할 수 있다.
    
- 정합성에 심각한 문제가 발생할 수 있다.

**READ COMMITED (커밋된 읽기)**

- 커밋한 데이터만 읽을 수 있다. (DIARY READ를 허용하지 않는다.)
- `NON-REPEATABLE READ` 문제가 발생할 수 있다.
    
    → 반복해서 같은 데이터를 읽을 수 없는 상태
    
- 대부분의 데이터베이스들은 보통 이 격리 수준을 기본으로 사용한다.

**REPEATABLE READ (반복 가능한 읽기)**

- 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다.
- `PHANTOM READ` 문제가 발생할 수 있다.
    
    → 반복 조회 시 결과 집합이 달라지는 것
    

**SERIALIZABLE (직렬화 가능)**

- 가장 엄격한 트랜잭션 격리 수준이다.
- 동시성 처리 성능이 급격히 떨어질 수 있다.

### 16.1.2 낙관적 락과 비관적 락 기초

**낙관적 락**

- 트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법
- JPA가 제공하는 버전 관리 기능을 사용 (== 애플리케이션이 제공하는 락)
- 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다.

**비관적 락**

- 트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법
- 데이터베이스가 제공하는 락 기능을 사용

**두 번의 갱신 분실 문제**

- 데이터베이스 트랜잭션 범위를 넘어서는 문제
- 두 트랜잭션이 동시에 작업하는 중에 트랜잭션1이 커밋하고 트랜잭션2가 커밋했다.
    
    → 결과적으로 트랜잭션1의 커밋 사항은 사라지고 트랜잭션2의 커밋 사항만 남게 된다.
    
- 문제를 해결하기 위해 3가지 선택 방법이 있다.
    - 마지막 커밋만 인정하기
    - 최초 커밋만 인정하기
    - 충돌하는 갱신 내용 병합하기

### 6.1.3 @Version

- 낙관적 락을 사용하기 위해서 `@Version` 어노테이션을 사용해서 버전 관리 기능을 추가해야 한다.
- 적용 가능한 타입이다.
    - Long (long)
    - Integer (int)
    - Short (short)
    - Timestamp
- 엔티티에 적용 관리용 필드를 하나 추가하고 `@Version` 을 붙이면 된다.
    
    ```java
    @Entity
    public class Board {
    
    	@Id
    	private String id;
    	private String title;
    
    	@Version
    	private Integer version;
    }
    ```
    
    - 엔티티를 수정할 때마다 버전이 하나씩 자동으로 증가한다.
    - 엔티티를 수정할 때 조회 시점의 버전과 수정 시점의 버전이 다르면 예외가 발생한다.
    - 따라서 버전 정보를 사용하면 **최초 커밋만 인정**하기가 적용된다.

### 16.1.4 JPA 락 사용

| 락 모드 | 타입 | 설명 |
| --- | --- | --- |
| 낙관적 락 | OPTIMISTIC | 낙관적 락을 사용한다. |
| 낙관적 락 | OPTIMISTIC_FORCE_INCREMENT | 낙관적 락 + 버전정보를 강제로 증가한다 |
| 비관적 락 | PESSIMISTIC_READ | 비관적 락, 읽기 락을 사용한다. |
| 비관적 락 | PESSIMISTIC_WRITE | 비관적 락, 쓰기 락을 사용한다. |
| 비관적 락 | PESSIMISTIC_FORCE_INCREMENT | 비관적 락 + 버전정보를 강제로 증가한다. |
| 기타 | NONE | 락을 걸지 않는다. |
| 기타 | READ | OPTIMISTIC 과 같다. |
| 기타 | WRITE | OPTIMISTIC_FORCE_INCREMENT 와 같다. |

### 16.1.5 JPA 낙관적 락

- 낙관적 락을 사용하려면 버전이 있어야 한다.
- 트랜잭션을 커밋하는 시점에 충돌을 알 수 있다. (예외 발생)
- NONE
    - 조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경되지 않아야 한다.
    - 조회 시점부터 수정 시점까지를 보장한다.
    - 엔티티를 수정할 때 버전을 체크하면서 버전을 증가한다.
    - 데이터베이스 버전 값이 현재 버전이 아니면 예외가 발생한다.
    - 두 번의 갱신 분실 문제를 예방한다.
- OPTIMISTIC
    - 조회한 엔티티는 트랜잭션이 끝날 때까지 다른 트랜젝션에 의해 변경되지 않아야 한다.
    - 조회 시점부터 트랜잭션이 끝날 때까지 조회한 엔티티가 변경되지 않음을 보장한다.
    - 커밋할 때 버전 정보를 조회해서 현재 버전과 같은 지 검증한다. (같지 않으면 예외)
    - DIARY READ와 NON-REPEATABLE READ를 방지한다.
- OPTIMISTIC_FORCE_INCREMENT
    - 논리적인 단위의 엔티티 묶음을 관리할 수 있다.
    - 엔티티를 수정하지 않아도 트랜잭션을 커밋할 때 버전 정보를 강제로 증가시킨다.
    - 데이터베이스의 버전이 엔티티의 버전과 다르면 예외가 발생한다.
    - 강제로 버전을 증가해서 논리적인 단위의 엔티티 묶음을 버전 관리할 수 있다.

### 16.1.6 JPA 비관적 락

- 엔티티가 아닌 스칼라 타입을 조회할 때도 사용할 수 있다.
- 데이터를 수정하는 즉시 트랜잭션 충돌을 감지할 수 있다.
- PESSIMISTIC_WRITE
    - 데이터베이스에 쓰기 락을 건다.
    - 데이터베이스 `select for update`를 사용해서 락을 건다.
    - NON-REPEATABLE READ를 방지한다.
    - 락이 걸린 로우는 다른 트랜잭션이 수정할 수 없다.
- PESSIMISTIC_READ
    - 데이터를 반복 읽기만 하고 수정하지 않는 용도로 락을 걸 때 사용한다.
- PESSIMISTIC_FORCE_INCREMENT
    - 비관적 락 중 유일하게 버전 정보를 사용한다.
    - 버전 정보를 강제로 증가시킨다.

### 16.1.7 비관적 락과 타임아웃

- 비관적 락을 사용하면 락을 획득할 때까지 트랜잭션이 대기한다.
- 이 때 무한정 대기하는 것을 방지하기 위해 타임아웃 시간을 준다.

---

## 16.2 2차 캐시

### 16.2.1 1차 캐시와 2차 캐시

- 조회한 데이터를 메모리에 캐시해서 데이터베이스 접근 횟수를 줄이면 애플리케이션 성능을 개선할 수 있다.
- 1차 캐시
    - 트랜잭션을 시작하고 종료할 때까지만 유효하다.
    - 전체적으로 볼 때 데이터베이스 접근 횟수를 획기적으로 줄이지는 못한다.
    - 영속성 컨텍스트 내부에 존재한다.
- 2차 캐시 (공유 캐시)
    - 대부분의 JPA 구현체들은 애플리케이션 범위의 캐시를 지원한다.
    - 애플리케이션을 종료할 때까지 캐시가 유지된다.
    - 엔티티 매니저를 통해 데이터를 조회할 때 우선 2차 캐시에서 찾고 없으면 데이터베이스에서 찾는다.
    - 영속성 유닛 범위의 캐시다.
    - 조회한 객체를 그대로 반환하는 것이 아니라 복사본을 만들어서 반환한다.
    - 영속성 컨텍스트가 다르면 객체 동일성을 보장하지 않는다.

### 16.2.2 JPA 2차 캐시 기능

- 캐시 모드 설정
    - 엔티티에 `@Cacheable` 어노테이션을 사용하면 된다.
- 캐시 조회, 저장 방식 설정
    - 캐시 조회 모드
        
        ```java
        public enum CacheRetrieveMode {
        	USE,    // 캐시에서 조회한다. 기본 값이다.
        	BYPASS. // 캐시를 무시하고 데이터베이스에 직접 접근한다.
        }
        ```
        
    - 캐시 보관 모드
        
        ```java
        public enum CacheStoreMode {
        	USE,     // 조회한 데이터를 캐시에 저장한다.
        	BYPASS,  // 캐시에 저장하지 않는다.
        	REFRESH  // 전략에 추가로 데이터베이스에서 조회한 엔티티를 최신 상태로 다시 캐시한다.
        }
        ```
        
    - JPA 캐시 관리 API
        - JPA는 캐시를 관리하기 위한 Cache 인터페이스를 제공한다.

### 16.2.3 하이버네이트와 EHCACHE 적용

- **엔티티 캐시**
    
    엔티티 단위로 캐시한다. 식별자로 엔티티를 조회하거나 컬렉션이 아닌 연관된 엔티티를 로딩할 때 사용한다.
    
- **컬렉션 캐시**
    
    엔티티와 연관된 컬렉션을 캐시한다. 컬렉션이 엔티티를 담고 있으면 식별자 값만 캐시한다.
    
- **쿼리 캐시**
    
    쿼리와 파라미터 정보를 키로 사용해서 캐시한다. 결과가 엔티티면 식별자 값만 캐시한다.
    
    - `StandardQueryCache`: 쿼리 캐시를 저장하는 영역
    - `UpdateTimestampsCache`: 쿼리 대상 테이블의 가장 최근 변경 시간을 저장하는 영역
- 캐시 영역
    - `엔티티 캐시 영역`: [패키지 명 + 클래스 명] 사용
    - `컬렉션 캐시 영역`: 엔티티 캐시 영역 이름에 캐시한 컬렉션의 필드 명 추가
- 쿼리 캐시나 컬렉션 캐시를 사용하면 결과 대상 엔티티에는 꼭 엔티티 캐시를 적용해야 한다.

---

## 16.3 정리

### 트랜잭션

- 트랜잭션의 격리 수준은 4단계가 있다. 격리 수준이 낮을수록 동시성은 증가하지만 격리 수준에 따른 다양한 문제가 발생한다.
- 영속성 컨텍스트는 데이터베이스 트랜잭션인 READ COMMITED 격리 수준이어도 애플리케이션 레벨에서 반복 가능한 읽기를 제공한다.

### 락

- JPA는 낙관적 락과 비관적 락을 지원한다. 낙관적 락은 애플리케이션이 지원하는 락이고, 비관적 락은 데이터베이스 트랜잭션 락 메커니즘에 의존한다.

### 2차 캐시

- 2차 캐시를 사용하면 애플리케이션 조회 성능을 극적으로 끌어올릴 수 있다.
