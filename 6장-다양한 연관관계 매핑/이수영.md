# 6장 다양한 연관관계 매핑

6장에서는 다양한 연관관계를 다룬다. 5장에서 배웠던 연관관계 매핑 시 고려해야하는 3가지를 고려해서 다양한 연관관계를 살펴볼 것이다.

1. 다중성 - 일대다, 다대일
2. 방향 - 단방향, 양방향
3. 연관관계 주인 - 외래키를 관리하는 객체

## 6.1 다대일

객체 양방향 관계에서 연관관계의 주인은 항상 다(N)쪽이다. → 테이블에서 외래키를 가지는 테이블이 다(N)쪽이기 때문.

### 6.1.1 다대일 단방향

단방향이라는 의미가 다쪽에서만 일쪽의 객체를 참조하고 있다고 생각하면 된다.

다쪽에서 외래키만 할당(JoinColumn)해주고 일쪽에서는 참조하지 않으니까 추가 작업이 필요없다.

### 6.1.2 다대일 양방향 [N:1, 1:N]

- 양방향은 외래 키가 있는 쪽이 연관관계 주인이다.
    
    : DB 관점에서 생각했을 때 외래키를 다쪽 테이블이 가지고 있음. 반대로 설정하면 추가적인 또 하나의 참조를 사용하는 식의 추가작업이 필요함.
    
- 양방향 연관관계는 항상 서로 참조해야 한다.
    
    : 양방향이라면 항상 서로 참조해야하고 연관관계 편의 메소드를 만드는 것이 좋은데 한 곳에만 생성하는 것도 가능하고 양쪽에 생성하는 것도 가능하지만 양쪽에 생성했을 때 무한루프에 빠질 수 있어 조심해야한다.
    
    → 추가적으로 비즈니스 로직을 잘 알고 있는 경우 양방향이 더 편할 수 있지만 그렇지 않은 사람이라면 실수를 유발할 수 있음.
    

## 6.2 일대다

다대일의 반대 방향이고 엔티티를 하나 이상 참조 가능해서 자바 컬렉션인 Collection, List, Set, Map 중 하나를 사용해야 한다.

### 6.2.1 일대다 단방향 [1:N]

하나의 팀이 여러 회원을 참조하고 있는 경우 일대다 관계라 한다. 이때 회원측에서 팀을 참조하지 않는 경우 일대다 단방향이다.

이 경우는 특이하다. 왜냐면 DB에서 외래키를 관리하는 테이블은 회원 테이블인데 외래키를 관리해야하는 객체는 팀이 되어야 하는 상황이다. 그래서 JoinColumn을 팀에서 선언한다.

이 방법의 단점은 위에서 말한 특이한 경우와 같은 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점이다. 기존엔 양방향 참조라서 아래처럼 쿼리가 3번만 나가도 충분하다.

```java

Team team = new Team();
em.persist(team); // insert team

Member member1 = new Member();
memeber1.setTeam(team);
Member member2 = new Member();
memeber2.setTeam(team);

em.persist(member1); // insert member1
em.persist(member2); // insert member2만
```

하지만 일대다 단방향인 경우라면 아래와 같이 update문이 추가로 나가면서 쿼리가 더 많아진다.

```java
Member member1 = new Member();
Member member2 = new Member();

Team team = new Team();
team.getMembers().add(member1);
team.getMembers().add(member2);

em.persist(member1); // insert member1
em.persist(member2); // insert member2
em.persist(team1); // insert team, update member1.fk, update member2.fk
```

- 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자.
    - 성능적뿐만 아니라 관리의 측면에서도 부담스러움.

### 6.2.2 일대다 양방향 [1:N, N:1]

일대다 양방향은 존재하지 않는다. 다대일 양방향 매핑을 사용해야한다.

→ @OneToMany는 연관관계의 주인이 될 수 없다. RDB의 특성상 외래키는 다쪽인 테이블에 존재하기 때문이다.

→ 완전 불가능하진 않지만 다대일 단방향 매핑을 읽기 전용으로 하나 따로 구성해야 하고 일대다 단방향 매핑이 가지는 단점을 모두 가지기에 다대일 양방향을 이용하자.

## 6.3 일대일

일대일 관계에서는 외래키를 주 테이블, 대상 테이블 모두에서 가질 수 있다. 그래서 어떤 테이블에서 가질지를 선택해야한다.

### 6.3.1 주 테이블에 외래 키

대상 객체를 참조하는 것처럼 주 테이블에 외래 키를 두고 사용하는 방법이다. 개발자들이 선호하고 좀 더 편리한 매핑이 가능하다.

- 단방향 : @OneToOne을 이용하고 나머지는 다대일 단방향과 비슷하다.
- 양방향 : 연관관계 주인을 주 테이블에 설정.

### 6.3.2 대상 테이블에 외래 키

- 단방향 : 대상 테이블에 외래 키가 있는 단뱡향 관계는 JPA에서 지원하지 않는다.
    - 이런 모양으로 매핑할 수 있는 방법도 없다.
    - 이 때는 단방향 관계를 Locker에서 Member 방향으로 수정하거나 양방향 관계로 만들고 Locker를 연관관계의 주인으로 설정해야한다.
- 양방향 : 대상 테이블에 연관관계 주인으로 설정하고 만든다.

➕ 프록시 사용 시 외래 키를 직접 관리하지 않는 일대일 관계는 지연 로딩으로 설정해도 즉시 로딩된다. → 프록시의 한계 때문에 발생하는 문제인데 프록시 대신 bytecode instrumentation을 사용하면 해결할 수 있다.

## 6.4 다대다

RDB는 다대다 관계를 테이블 2개로 표현할 수 없다. 그래서 중간 테이블을 이용한다.

하지만 객체는 객체 2개로 다대다를 표현할 수 있다. → @ManyToMany를 이용하여 편하기 이용할 수 있다.

### 6.4.1 다대다 : 단방향

JPA에서 중간 테이블을 지원해줘서 중간 테이블에 관한 쿼리가 없어도 내부적으로 처리가 되어서 자동으로 중간 테이블 관련된 쿼리가 날라간다. @ManyToMany를 통해 쉽게 이용할 수 있다.

### 6.4.2 다대다 : 양방향

이것도 마찬가지로 역방향으로 @ManyToMany를 붙여준다.그리고 양쪽중 원하는 곳에 연관관계 주인을 설정한다.

### 6.4.3 다대다 : 매핑의 한계와 극복, 연결 엔티티 사용

JPA에서 @ManyToMany 이용 시 중간 테이블을 자동으로 처리해주는데 실무에서 사용하긴 한계가 존재한다. 일반적으로 중간 테이블에는 수량, 주문한 날짜 등의 필드들이 추가된다. 하지만 이를 주문 엔티티나 상품 엔티티에서 매핑할 수 없다. → 왜냐면 중간 테이블에만 존재하는 필드니까 그래서 일대다, 다대일, 중간테이블을 이용해서 풀어야한다.

이과정에서 @IdClass를 이용하여 내가 직접 식별자 클래스를 통해 식별자를 만들 수 있다. 주문 id와 유저 id를 섞어서 만든 것처럼 할 수 있다. → 이를 복합 기본 키라고 부른다.

- 복합 기본 키 특징
    - 별도의 식별자 클래스를 생성해야함.
    - Serializable을 구현해야함.
    - equals and hashCode 구현해야함.
    - 기본 생성자가 있어야함.
    - 식별자 클래스가 public이어야 함.
    - @IdClass 외에도 @EmbeddedId를 사용하는 방법도 존재함.

이렇게 부모 테이블의 기본 키를 받아서 자신의 기본 키와 외래 키로 사용하는 것을 식별 관계라고 한다. → 복합 키의 특징을 다 구현해야 해서 복잡하고 처리할 일이 상당히 많아짐.

### 6.4.4 다대다 : 새로운 기본 키 사용

추천하는 기본 키 생성 전략은 DB에서 자동으로 생성해주는 Long 형식의 대리 키를 이용하는 방법이다. 장점은 간편하고 영구적 사용이 가능하며 비즈니스에 의존하지 않는다.

복합 키 사용보다 매핑이 단순하고 이해하기 쉽다.

### 6.4.5 다대다 연관관계 정리

- 식별 관계 : 받아온 식별자를 기본 키 + 외래 키로 사용.
- 비식별 관계 : 받아온 식별자를 외래 키로만 사용 대리 키 이용.

⇒ 비식별 관계를 이용하자. 비즈니스에 의존하지 않는게 크다고 생각.

⇒ 명환님 회사에서 인수인계 받은 코드에서 복합 키를 이용하여 이를 해결하는데 고생중이라고 했었음.
