# 15. 고급 주제와 성능 최적화

## 15.1 예외 처리

### 15.1.1 JPA 표준 예외 정리

1. 트랜잭션 롤백을 표시하는 예외
    
    → 심각한 예외이므로 복구해서는 안 된다.
    
2. 트랜잭션 롤백을 표시하지 않는 예외
    
    → 심각한 예외가 아니므로 개발자가 트랜잭션을 커밋할지 롤백할지 판단할 수 있다.
    

### 15.1.2 스프링 프레임워크의 JPA 예외 변환

서비스 계층에서 JPA의 예외를 직접 사용하면 JPA에 의존하게 된다. 이런 문제를 해결하기 위해서, 스프링 프레임워크는 데이터 접근 계층에 대한 예외를 추상화해서 개발자에게 제공한다.

- ex
    
    javax.persistence.PersistenceException
    
    → org.springframework.orm.jpa.JpaSystemException
    
    javax.persistence.NoResultException
    
    → org.springframework.dao.EmpthResultDataAccessException
    

### 15.1.3 스프링 프레임워크에 JPA 예외 변환기 적용

`@Repository` 어노테이션을 사용한 곳에 예외 변환 AOP를 적용해서 JPA 예외를 스프링 프레임워크가 추상화한 예외로 변환해준다.

```java
@Bean
public PersistenceExceptionTranslationPostProcessor exceptionTranslation() {
	return new PersistenceExceptionTranslationPostProcessor();
}
```

### 5.1.4 트랜잭션 롤백 시 주의사항

트랜잭션을 롤백하는 것은 **데이터베이스의 반영사항만 롤백**하는 것이지 수정한 자바 객체까지 원상태로 복구해주지 않는다. 따라서 트랜잭션이 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험하다. 새로운 영속성 컨텍스트를 생성해서 사용하거나 `EntityManager.clear()`를 호출해서 **영속성 컨텍스트를 초기화**한 다음에 사용해야 한다.

---

## 15.2 엔티티 비교

### 15.2.1 영속성 컨텍스트가 같을 때 엔티티 비교

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1d8fbc70-896b-48da-a948-e4ecf4546c85/Untitled.png)

- 항상 같은 트랜잭션에서 같은 영속성 컨텍스트에 접근한다.
- 영속성 컨텍스트가 같으면 엔티티를 비교할 때 다음 3가지 조건을 모두 만족한다.
    1. 동일성: `==` 비교가 같다.
    2. 동등성: `equals()` 비교가 같다.
    3. 데이터베이스 동등성: `@Id` 인 데이터베이스 식별자가 같다.

### 15.2.2 영속성 컨텍스트가 다를 때 엔티티 비교

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/38f55fd7-5c5b-444c-8108-a9c1ce540cf9/Untitled.png)

- 영속성 컨텍스트가 다르면 동일성 비교에 실패한다. 영속성 컨텍스트가 다를 때 엔티티 비교는 다음과 같다.
    1. 동일성: `==` 비교가 실패한다.
    2. 동등성: `equals()` 비교가 만족한다. (단, 구현해야 함)
    3. 데이터베이스 동등성: `@Id` 인 데이터베이스 식별자가 같다.
- 엔티티를 비교할 때는 비즈니스 키를 활용한 동등성 비교를 권장한다.
    
    → 데이터베이스 기본 키 후보들이 좋은 대상이다.
    
- 동일성 비교는 같은 영속성 컨텍스트의 관리를 받는 영속 상태의 엔티티에만 적용할 수 있다. 그렇지 않으면 비즈니스 키를 사용한 동등성 비교를 해야 한다.

---

## 15.3 프록시 심화 주제

### 15.3.1 영속성 컨텍스트와 프록시

- 영속성 컨텍스트는 프록시로 조회된 엔티티에 대해서 같은 엔티티를 찾는 요청이 오면 원본 엔티티가 아닌 처음 조회된 **프록시를 반환**한다.
- 프록시로 조회해도 영속성 컨텍스트는 영속 엔티티의 동일성을 보장한다.
- 프록시가 아닌 원본을 호출할 때에도 영속 엔티티의 동일성을 보장한다.

### 15.3.2 프록시 타입 비교

- 프록시는 원본 엔티티의 자식 타입이므로 `instanceof` 연산을 사용하면 된다.

### 15.3.3 프록시 동등성 비교

- 프록시의 타입 비교는 `==` 비교 대신에 `instanceof` 를 사용해야 한다.
- 프록시의 멤버변수에 직접 접근하면 안 되고 대신에 **접근자 메소드**를 사용해야 한다.
    - member.name → ❌
    - member.getName() → ⭕

### 15.3.4 상속관계와 프록시

- 프록시를 부모 타입으로 조회하면 부모의 타입을 기반으로 프록시가 생성되는 문제가 있다.
    - `instanceof` 연산을 사용할 수 없다.
    - 하위 타입으로 다운캐스팅을 할 수 없다.
- 상속관계에서 발생하는 프록시 문제를 해결하는 아래의 방법들이 있다.
    - **JPQL로 대상 직접 조회**
        
        처음부터 자식 타입을 직접 조회해서 필요한 연산을 하면된다.
        
        다형성을 활용할 수 없다.
        
    - **프록시 벗기기**
        
        하이버네이트가 제공하는 기능을 사용하면 프록시에서 원본 엔티티를 가져올 수 있다.
        
        원본 엔티티를 직접 꺼내기 때문에 프록시와 원본 엔티티의 동일성 비교가 실패한다는 문제점이 있다.
        
        원본 엔티티가 꼭 필요한 곳에서 잠깐 사용되고 다른 곳에서 사용되지 않도록 하는 것이 중요하다.
        
    - **기능을 위한 별도의 인터페이스 제공**
        
        인터페이스를 제공하고 각각의 클래스에 맞는 기능을 구현하는 것은 다형성을 활용하는 좋은 방법이다.
        
    - **비지터 패턴 사용**
        
        <aside>
        💡 **장점**
        프록시에 대한 걱정 없이 안전하게 원본 엔티티에 접근할 수 있다.
        instanceof와 타입캐스팅 없이 코드를 구현할 수 있다.
        알고리즘과 객체 구조를 분리해서 구조를 수정하지 않고 새로운 동작을 추가할 수 있다.
        
        **단점**
        너무 복잡하고 더블 디스패치를 사용하기 때문에 이해하기 어렵다.
        객체 구조가 변경되면 모든 비지터를 수정해야 한다.
        
        </aside>
        
        - 대상 클래스 작성
        - 비지터 패턴 실행
        - 비지터 패턴과 확장성

---

## 15.4 성능 최적화

### 15.4.1 N+1 문제

- 처음 실행한 SQL의 결과 수만큼 추가로 SQL을 실행하는 것
- **즉시 로딩과 N+1**
    
    → JPQL을 실행할 때 N+1 문제가 발생할 수 있다.
    
- **지연 로딩과 N+1**
    
    → 비즈니스 로직에서 컬렉션을 실제 사용할 때 지연 로딩이 발생되면서 N+1 문제가 발생할 수 있다.
    
- **페치 조인 사용**
    
    → N+1 문제를 해결하는 가장 일반적인 방법이다.
    
    → SQL 조인을 사용해서 연관된 엔티티를 함께 조회ㅣ하므로 N+1 문제가 발생하지 않는다.
    
- **하이버네이트 @BatchSize**
    
    → 하이버네이트가 제공하는 BatchSize 어노테이션을 사용하면 연관된 엔티티를 조회할 때 지정한 size 만큼 SQL의 IN 절을 사용해서 조회한다.
    
- **하이버네이트 @Fetch(FetchMode.SUBSELECT)**
    
    → 하이버네이트가 제공하는 Fetch 어노테이션에 FetchMode를 SUBSELECT로 사용하면 연관된 데이터를 조회할 때 서브 쿼리를 사용해서 N+1 문제를 해결한다.
    
    → 즉시 로딩으로 설정하면 조회 시점에, 지연 로딩으로 설정하면 지연 로딩된 엔티티를 사용하는 시점에 다음 SQL이 실행된다.
    
    ```java
    SELECT O FROM ORDERS O
    	WHERE O.MEMBER_ID IN (
    		SELECT M.ID
    		FROM MEMBER M
    		WHERE M.ID > 10
    	)
    ```
    
- N+1 정리
    
    → 기본 값이 즉시 로딩인 `@OneToOne` 과 `@ManyToOne` 은 fetch = FetchType.LAZY 로 설정해서 지연 로딩 전략을 사용하도록 변경하는 것을 권고한다.
    

### 15.4.2 읽기 전용 쿼리의 성능 최적화

- 스칼라 타입으로 조회 `메모리 최적화`
    
    ```java
    select o.id, o.name, o.price from Order p
    ```
    
- 읽기 전용 쿼리 힌트 사용 `메모리 최적화`
    
    → 메모리 사용량 최적화할 수 있다.
    
    ```java
    TypedQuery<Order> query = em.createQuery*"select o from Order o", Order.class);
    query.setHint("org.hibernate.readOnly", true);
    ```
    
- 읽기 전용 트랜잭션 사용 `속도 최적화`
    
    → 트랜잭션을 커밋해도 영속성 컨텍스트를 플러시하지 않는다.
    
    ```java
    @Transactional(readOnly = true)
    ```
    
- 트랜잭션 밖에서 읽기 `속도 최적화`
    
    → 트랜잭션 없이 엔티티를 조회한다.
    
    ```java
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    ```
    
- 정리
    - 읽기 전용 트랜잭션 사용: 플러시를 작동하지 않도록 해서 성능 향상
    - 읽기 전용 엔티티 사용: 엔티티를 읽기 전용으로 조회해서 메모리 절약

### 15.4.3 배치 처리

- JPA 등록 배치
    
    → 배치 처리는 아주 많은 데이터를 조회해서 수정한다. 한번에 메모리에 올릴 수 없기 때문에 2가지 방법을 주로 사용한다.
    
    - **페이징 처리**: 데이터베이스 페이징 기능 사용
    - **커서**: 데이터베이스가 지원하는 커서 기능 사용
- JPA 페이징 배치 처리
    
    → 한번에 일정 개수만큼 페이징 쿼리로 조회한다.
    
    → 페이지 단위마다 영속성 컨텍스트를 플러시하고 초기화한다.
    
- 하이버네이트 scroll 사용
    
    → 쿼리를 조회하면서 scroll() 메소드로 ScrollableResults 객체를 반환받는다.
    
    → 객체의 `next()` 메소드를 호출하면 엔티티를 하나씩 조회할 수 있다.
    
- 하이버네이트 무상태 세션 사용
    
    → 영속성 컨텍스트를 만들지 않고 2차 캐시도 사용하지 않는다.
    
    → `update()` 메소드를 직접 호출해야 한다.
    
    → 일반 하이버네이트 세션과 거의 비슷하지만 영속성 컨텍스트가 없다.
    

### 15.4.4 SQL 쿼리 힌트 사용

- SQL 힌트를 사용하려면 하이버네이트를 직접 사용해야 한다.
- 하이버네이트 쿼리가 제공하는 `addQueryHint()` 메소드를 사용한다.

### 15.4.5 트랜잭션을 지원하는 쓰기 지연과 성능 최적화

- 트랜잭션을 지원하는 쓰기 지연과 JDBC 배치
- 트랜잭션을 지원하는 쓰기 지연과 애플리케이션 확장성
    
    → 데이터베이스 테이블 row에 lock이 걸리는 시간을 최소화한다.
    

---

## 15.5 정리

### 15.1 예외 처리

- JPA의 예외는 트랜잭션 롤백을 표시하는 예외와 표시하지 않는 예외로 나눈다.
트랜잭션을 롤백하는 예외는 심각한 예외이므로 트랜잭션을 강제로 커밋해도 커밋되지 않고 롤백된다.
- 스프링 프레임워크는 JPA의 예외를 스프링 프레임워크가 추상화한 예외로 변환해준다.

### 15.2 엔티티 비교

- 같은 영속성 컨텍스트의 엔티티를 비교할 때는 동일성 비교를 할 수 있지만 영속성 컨텍스트가 다르면 동일성 비교에 실패한다.
따라서 자주 변하지 않는 비즈니스 키를 사용한 동등성 비교를 해야 한다.

### 15.3 프록시 심화 주제

- 프록시를 사용하는 클라이언트는 조회한 엔티티가 프록시인지 아니면 원본 엔티티인지 구분하지 않고 사용할 수 있어야 한다.
하지만 프록시는 기술적인 한계가 있으므로 한계점을 인식하고 사용해야 한다.

### 15.4 성능 최적화

- JPA를 사용할 때는 N+1 문제를 가장 조심해야 한다.
N+1 문제는 주로 페치 조인을 사용해서 해결한다.
- 엔티티를 읽기 전용으로 조회하면 스냅샷을 유지할 필요가 없고 영속성 컨텍스트를 플러시하지 않아도 된다.
- 대량의 엔티티를 배치 처리하려면 적절한 시점에 꼭 플러시를 호출하고 영속성 컨텍스트도 초기화 해야 한다.
- JPA는 지원하지 않지만 하이버네이트 구현체를 사용하면 SQL 쿼리 힌트를 사용할 수 있다.
- 트랜잭션을 지원하는 쓰기 지연 덕분에 SQL 배치 기능을 사용할 수 있다.
