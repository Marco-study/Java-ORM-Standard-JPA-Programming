# 15.1 예외 처리

JPA 표준 예외들은 javax.persistence.PersistenceException의 자식 클래스들이고 이는 RuntimeException을 상속받기 때문에 JPA 표준 예외는 모두 unchecked exception이다.

이 예외들은 2가지로 나뉘는 롤백을 표시하는 예외와 표시하지 않는 예외이다.

롤백을 표시하는 예외는 치명적이라서 무조건 롤백을 해야한다는 의미이고 롤백을 표시하지 않는 예외는 개발자가 롤백을 할 지 커밋을 할 지 선택을 해도 되는 그런 의미이다.

### 트랜잭션 롤백을 표시하는 예외

| javax.persistence.EntityExistsException | EntityManager.persist() 호출 시 이미 같은 엔티티가 있으면 발생 |
| --- | --- |
| javax.persistence.EntityNotFoundException | EntityManager.getReference()를 호출했는데 실제 사용 시 엔티티가 존재하지 않으면 발생. refresh(), lock()에서도 발생. |
| javax.persistence.OptimisticLockException | 낙관적 락 충돌 시 발생. |
| javax.persistence.PessimisticLockException | 비관적 락 충돌 시 발생. |
| javax.persistence.RollbackException | EntityTransaction.commit() 실패 시 발생, 롤백이 표시되어 있는 트랜잭션 커밋 시에도 발생. |
| javax.persistence.TransactionRequiredException | 트랜잭션이 필요할 때 트랜잭션이 없으면 발생, 트랜잭션 없이 엔티티를 변경할 때 주로 발생. |

### 트랜잭션 롤백을 표시하지 않는 예외

| javax.persistence.NoResultException | Query.getSingleResult() 호출 시 결과가 하나도 없을 때 발생. |
| --- | --- |
| javax.persistence.NonUniqueResultException | Query.getSingleResult() 호출 시 결과가 둘 이상일 때 발생. |
| javax.persistence.LockTimeoutException | 비관적 락에서 시간 초과 시 발생 |
| javax.persistence.QueryTimeoutException | 쿼리 실행 시간 초과 시 발생. |

서비스 계층에서 데이터 접근 구현 기술에 의존하는 것은 좋을 설계라고 볼 수 없는데 이는 예외에서도 마찬가지다. 그래서 JPA의 표준 예외를 사용하는 것은 JPA에 의존하게 되어 좋지 않고 그래서 스프링에서는 이를 추상화한 예외를 제공해준다. 이는 책에서 한번 확인해보는 것이 좋을 것같다.

이런 추상화된 예외로 변경하려면 `PersistenceExceptionTranslationPostProcessor` 를 스프링 빈으로 등록하면 된다. 이것은 `@Repository` 어노테이션을 사용한 곳에 예외 변환 AOP를 적용해서 JPA 예외를 스프링 프레임워크가 추상화한 예외로 변환해준다.

```java
<bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor">
```

요런 식으로 설정할 수 있다.

트랜잭션 롤백할 때 주의해야할 점들이 있는데 롤백을 하면 DB상에 반영된 사항만 롤백을 하는 것이지 수정한 자바 객체까지 원상태로 복구하지 않는다. 그래서 수정된 객체는 영속성 컨텍스트에 그대로 남아있게 되는데 이를 그대로 사용하는 것은 위험하여 스프링 프레임워크는 이런 문제를 예방하기 위해서 영속성 컨텍스트의 범위에 따라 다른 방법을 사용한다. 그래서 기본 전략인 트랜잭션당 영속성 컨텍스트 전략은 롤백하면서 컨텍스트가 같이 종료되기에 문제가 없다.

하지만 OSIV와 같이 컨텍스트 범위를 트랜잭션 범위보다 넓게 사용하면 문제가 될 수 있다. 그래서 스프링 프레임워크는 트랜잭션 롤백시 영속성 컨텍스트 를 초기화해서 이런 문제를 예방한다.

# 15.2 엔티티 비교

영속성 컨텍스트 내붕에는 엔티티 인스턴스를 보관하기 위한 1차 캐시가 있고 그래서 같은 영속성 컨텍스트에서 관리되는 엔티티는 완전 아예 같은 인스턴스다. 그래서 `==` 를 해도 같다고 나온다. 그니까 같은 컨텍스트에서 생성되고 조회를 하면 아예 같은 인스턴스다.

다른 영속성 컨텍스트에서는 이것이 성립되지 않기에 테스트 시 잘 확인을 해야한다.

`@Transactional` 이 어디에 붙었는지에 따라서 영속성 컨텍스트의 범위가 달라지는데 테스트 스위트에 붙어있다면 해당 테스트는 전부 같은 영속성 컨텍스트를 사용한다고 생각하면 된다. 그래서 만약 테스트 스위트에 `@Transactional` 을 붙이지 않고 그냥 시도하면 트랜잭션의 범위를 잘 생각해야 하고 트랜잭션 당 영속성 컨텍스트임을 잘 확인해야한다ㅏ.

만약 다른 영속성 컨텍스트에서 관리되는 엔티티간 비교를 하고 싶다면 동등성을 확인해야 하는데 그냥 ID가 있다면 그걸 비교하는 걸로도 동등성을 확인할 수 있기에 이를 이용하자.

# 15.3 프록시 심화 주제

원본 엔티티와 프록시를 구분하지 않고 사용할 수 있다. 하지만 프록시를 사용하는 방식의 기술적인 한계로 인해 예상하지 못한 문제들이 발생하기도 하는데 어떤 문제가 발생하고 어떻게 해결해야 하는지 알아보자.

영속성 컨텍스트는 자신이 관리하는 영속 엔티티의 동일성을 보장한다. 프록시로 조회한 엔티티도 그럴까? 그렇지 않다.

그래서 영속성 컨테스트는 프록시로 조회된 엔티티에 대해서 같은 엔티티를 찾는 요청이 오면 원본 엔티티가 아닌 처음 조회된 프록시를 반환한다. 반대로 원본 엔티티를 먼저 조회하고 나서 프록시를 조회하면 어떻게 될까? 이는 원본 엔티티를 먼저 조회했기에 프록시를 반환할 이유가 없어 프록시가 아닌 원본을 반환한다. 

프록시의 타입 비교시에는 `==` 비교가 아닌 `instanceof` 연산을 사용하면 된다.

`equals()` 메소드로 엔티티를 비교할 때 비교 대상이 원본 엔티티면 문제가 없지만 프록시면 문제가 발생할 수 있다. 즉, 원본 엔티티와 프록시 엔티티를 `equals()` 를 통한 동등성 비교 시 문제가 발생할 수 있다. 그 이유는 일반적으로 `equals()` 내부에서는 `≠, ==` 를 이용해서 타입을 비교하는데 프록시는 위에서 말했듯이 `instanceof` 를 이용해야 한다. 그리고 일반적으로 멤버변수를 직접 비교하게 구현이 되는데 프록시는 직접 접근으로는 아무값도 조회할 수 없다. (프록시니까) 따라서 null이 반환되고 `false`가 되는 것이다.

그래서 프록시의 데이터를 조회할 때는 `getter`를 사용해야 한다. 코드를 수정해보자.

```java
@Override
public boolean equals(Object obj) {
	if (this == obj) return true;
	if (! (obj instanceof Member)) return false;
	
	Member member = (Member) obj;
	
	if(name != null ? !name.equals(member.getName()) : member.getName() != null)
		return false;
	
	return true;	
}

```

- 프록시의 타입 비교는 `==` 대신 `instanceof` 를 사용해야 한다.
- 프록시는 멤버변수에 직접 접근할 수 없고 접근자(Getter)를 이용해야한다.

프록시는 상속관계에서 문제가 생길 수 있는데 프로시를 부모 타입으로 조회하면 문제가 발생한다.

em.getReference() 메소드를 사용해서 Item 엔티티를 프록시로 조회하면 실제 조회된 엔티티는 Book이라서 Book 타입을 기반으로 프록시가 만들어진다. 근데 부모인 Item을 이용해서 em.getReference()를 하게 되면 Item을 기반으로 프록시가 만들어진다. 이 프록시 클래스는 원본 엔티티로 Book 엔티티를 참조한다. 

근데 Item을 기반으로 만들어졌으니까 Item$Proxy 타입이고 이 타입은 Book 타입과 관계가 없다. 그래서 `proxyItem instanceof Book` 이는 `false`가 도출된다. 그럼 다운캐스팅을 하면 될까? 예외가 터질 것이다. 앞서 말했듯이 Item$Proxy는 Book과 아무런 관계가 없기 때문이다.

이런 문제는 주로 다형성을 다루는 도메인 모델에서 나타난다. 이 문제를 어떻게 해결할 수 있을까?

 

### JPQL로 대상 직접 조회

가장 간단하게는 처음부터 자식 타입을 직접 조회해서 필요한 연산을 하면 되나 이 방법은 다형성을 활용할 수 없다.

### 프록시 벗기기

하이버네이트가 제공하는 기능을 사용하면 프록시에서 원본 엔티티를 가져올 수 있다. `unProxy()` 를 이용하면 프록시에서 원본 엔티티를 직접 꺼내게 되는데 이렇게 되었을 때 프록시와 원본 엔티티의 동일성 비교는 실패하게 된다. 그래서 이 방법을 사용할 때는 원본 엔티티가 꼭 필요한 곳에서 잠깐 사용하고 다른 곳에서 사용되지 않게 하는 것이 중요하다. 참고로 원본 엔티티의 값을 직접 변경해도 변경 감지는 동작한다.

### 기능을 위한 별도의 인터페이스 제공

```java
public interface TitleView {
	String getTitle();
}
```

이런 식으로 모든 자식 클래스들이 구현하는 인터페이스를 만들고 getTiltle 호출을 통해서 구현체에 따라서 각기 다른 메소드를 호출할 수 있게 만들고 이 방법은 상품이 추가되어도 Item을 사용하는 OrderItem의 코드는 수정하지 않아도 된다. 그리고 이 방법은 클라이언트 입장에서 대상 객체가 프록시인지 아닌지를 고민하지 않아도 되는 장점이 있다.

이 방법을 사용할 때는 프록시의 특징 때문에 프록시의 대상이 되는 타입에 인터페이스를 적용해야 한다. 여기서는 Item이 프로시의 대상이므로 Item이 인터페이스를 받아야한다.

### 비지터 패턴 사용

비지터 패턴은 Visitor와 Visitor를 받아들이는 대상 클래스로 구성된다. 여기서는 Item이 accept (Visitor)를 받아들인다. 그리고 Item은 단순히 Visitor를 받아들이기만 하고 실제 로직은 visitor가 처리한다.

visit() 라는 메소드를 정의하고 모든 대상 클래스를 받아들이도록 작성하면 된다. 여기선 Book, Album, Movie를 대상 클래스로 사용한다. 대상 클래스의 내용을 출력해주는 PrintVisitor와 대상 클래스의 제목을 보관하는 TitleVisitor를 작성했다.

- 대상 클래스 작성
    - 엔티티 내부에 accept(Visitor) 메소드를 구현한다.
    
    ```java
    @Override
    public void accept(Visitor visitor) {
    	visitor.visit(this);
    }
    
    ---
    
    item.accept(new PrintVisitor());
    ```
    
    - 실제 로직 처리를 visitor로 위임.
    
    프록시에서 이를 이용하면 item은 포록시이므로 먼저 프록시가 accept 메소드를 받고 원본 엔티티(book)의 accept()를 실행한다. 원본 엔티티는 다음 코드를 실행해서 자신(this)을 visitor에 파라미터로 넘겨준다. 이 때 this는 원본 엔티티이다.
    

해당 방식을 이용하게 되면 프록시에 대한 걱정 없이 안전하게 원본 엔티티에 접근할 수 있고 instanceof나 타입 캐스팅 없이 코드를 구현할 수 있는 장점이 있다. 확장할 때도 기존 코드를 건드리지 않아도 된다는 장점이 있다.

- 비지터 패턴 정리
    - 장점
        - 프록시에 대한 걱정 없이 안전하게 원본 엔티티에 접근할 수 있다.
        - instanceof와 타입캐스팅 없이 코드를 구현할 수 있다.
        - 알고리즘과 객체 구조를 분리해서 구조를 수정하지 않고 새로운 동작을 추가할 수 있다.
    - 단점
        - 너무 복잡하고 더블 디스패처를 사용하기 때문에 이해하기 어렵다.
        - 객체 구조가 변경되면 모든 Visitor를 수정해야 한다.

# 15.4 성능 최적화

### N+1 문제

JPA로 애플리케이션 개발 시 성능상 가장 주의해야 하는 것이 N+1 문제이다.

회원과 주문이 1:N, N:1 양방향 관계이다.

- 즉시 로딩과  N+1
    
    특정 회원 하나를 em.find() 메소드로 조회하면 즉시 로딩으로 설정한 주문정보도 함께 조회한다.
    
    ```sql
    SELECT M.*, O.*
    FROM 
    	Member M
    OUTER JOIN ORDERS O ON M.ID=O.MEMBER_ID
    ```
    
    요렇게 조회문을 여러 번 날리는게 아닌 한번으로 멤버 정보랑 주문 정보를 한번에!! 아따 지긴다
    
    하지만 JPQL을 사용하면 문제가 생긴다는 점(dot)
    
    JPQL을 이용하면 JPA에서 분석해서 지맘대로 SQL을 작성하는데 즉시 로딩, 지연 로딩을 전혀 신경 쓰지 않는다. 그래서 아래와 같은 SQL을 작성하는데
    
    ```sql
    SELECT * FROM MEMBER;
    ```
    
    먼저 멤버 정보를 다 들고온다 근데 보니까 즉시로딩이네? JPA는 주문을 들고 와야징 생각을 하면서 SQL을 추가로 실행한다.
    
    ```sql
    SELECT * FROM MEMBER; // 회원 5명이 조회된다고 생각하자.
    SELECT * FROM ORDERS WHERE MEMBER_ID=1;
    SELECT * FROM ORDERS WHERE MEMBER_ID=2;
    SELECT * FROM ORDERS WHERE MEMBER_ID=3;
    SELECT * FROM ORDERS WHERE MEMBER_ID=4;
    SELECT * FROM ORDERS WHERE MEMBER_ID=5;
    ```
    
    이렇게 회원 한명 한명 마다 어? 연관관계가 있네? 즉시 로딩이니까 조회해야징 하면서 멤버 하나마다 연관된 엔티티들에 대한 조회문이 발생한다.
    
    총 N번에 대해서 추가적인 조회문이 발생하여 N+1 문제라고 부른다.
    
- 지연 로딩과 N+1
    
    그러면 지연로딩으로 설정하면 어떻게 될까? 방금 살펴본 즉시 로딩 시나리오를 지연 로딩으로 변경해도 N+1 문제에서 자유로울 수는 없다. 지연로딩에서는
    
    ```sql
    SELECT * FROM MEMBER;
    ```
    
    요 조회문만 날라간다. 와 N+1 발생안하네? 하지만 이후 비즈니스 로직에서 해당 연관된 엔티티 컬렉션을 사용할 때 문제가 발생한다. `firstMember.getOrders().size()` 요걸 치면 아래와 같은 조회문이 발생한다.
    
    ```sql
    SELECT * FROM ORDERS WHERE MEMBER_ID=?
    ```
    
    근데 문제는 이런게 모든 멤버에 대해 연관된 주문 컬렉션 사용시마다 조회문이 발생하는 것이다. 결국 이것도 N+1 문제다.
    

그러면 이를 어떻게 예방할 수 있을까?

- fetch 조인 사용
    
    가장 일반적인 방법은 페치 조인을 사용하는 것이다. 페치 조인은 SQL 조인을 사용해서 연관된 엔티티 를 함께 조회하므로 N+1 문제가 발생하지 않는다.
    
    ```sql
    SELECT m FROM MEMBER m join fetch m.orders; // JPQL
    
    SELECT M.*, O.* FROM MEMBER M
    INNER JOIN ORDERS O ON M.ID=O.MEMBER_ID; 
    ```
    
    참고로 이 예제는 일대다 조인을 했으므로 결과가 늘어나서 중복된 결과가 나타날 수 있어서 JPQL의 DISTINCT를 사용해서 중복을 제거하는 것이 좋다.
    
- 하이버네이트 @BatchSize
    
    하이버네이트가 제공하는 해당 어노테이션을 사용하면 연관된 엔티티를 조회할 때 지정한 size만큼 SQL의 IN 절을 사용해서 조회한다. 만약 조회한 회원이 10명인데 size=5로 지정하면 2번의 SQL만 추가로 실행한다.
    
    필드에 `@BatchSize`를 붙이면 된다. `hiberanate.default_batch_fetch_size` 속성을 통해 애플리케이션 전체에 기본적으로 @BatchSize를 적용할 수 있다.
    
- 하이버네이트 @Fetch(FetchMode.SUBSELECT)
    
    FetchMode를 SUBSELECT로 사용하면 연관된 데이터를 조회할 때 서브 쿼리를 사용해서 N+1 문제를 해결한다.
    
- N+1 정리
    
    즉시 로딩과 지연 로딩 중 추천하는 방법은 지연로딩만 사용하는 것. 즉시로딩의 가장 큰 문제는 성능 최적화가 어렵다는 것. 지연 로딩을 이용하고 성능 최적화가 꼭 필욯나 곳에는 JPQL 페치 조인을 사용하자.
    

### 읽기 전용 쿼리의 성능 최적화

엔티티가 영속성 컨텍스트에서 관리될 시 혜택이 많지만 스냅샷 인스턴스를 보관해야 해서 메모리를 더 많이 사용한다. 예를 들어 100건의 구매 내용을 출력하는 단순 조회 화면이 있다고 가정하면 수정될 일도 없고 딱 한 번만 읽어서 화면에 출력하면 된다. 이 때는 읽기 전용으로 엔티티 조회 시 메모리 사용량을 최적화할 수 있다.

- 스칼라 타입으로 조회
    
    스칼라 타입은 영속성 컨텍스트가 결과를 관리하지 않는다.
    
    ```sql
    select o.id, o.name, o.price from ORder p;
    ```
    
- 읽기 전용 쿼리 힌트 사용
    
    readOnly를 이용해서 읽기 전용으로 조회할 수 있다. 이는 영속성 컨텍스트에서 스냅샷을 보관하지 안흔다. 따라서 메모리 사용량을 최적화할 수 있다. 단 스냅샷이 없으므로 엔티티를 수정해도 DB엔 바영되지 않는다.
    
- 읽기 전용 트랜잭션 사용
    
    스프링 프레임워크를 사용하면 트랜잭션을 읽기 전용 모드로 설정할 수 있다. 
    
    ```sql
    @Transactional(readOnly = true)
    ```
    
    플러시 모드를 MANUAL로 설정한다. 이렇게 하면 강제로 플러시를 호출하지 않는 한 플러시가 일어나지 않늗나. 따라서 트랜잭션을 커밋해도 영속성 컨텍스트를 플러시하지 않는다.영속성 컨텍스트 를 플러시 하지 않아서 엔티티의 등록, 수정, 삭제는 당연히 동작하지 않는다. 하지만 플러시할 때 일어나는 스냅샷 비교와 같은 무거운 로직들을 수행하지 않으므로 성능이 향상되낟. 물론 트랜잭션을 시작했으므로 트랜잭션 시작, 로직수행, 트랜잭션 커밋의 과정은 이루어는 진다. 단지 영속성 컨텍스트를 플러시하지 않을 뿐이다.
    
- 트랜잭션 밖에서 읽기
    
    트랜잭션 밖에서 읽는다는 것은 트랜잭션 없이 엔티티를 조회한다는 뜻이다. 물론 데이터 변경 시엔 필수다 그래서 조회의 목적인 경우만 사용하자. → 플러시가 일어나지 않아서 조회 성능이 향상된다. 트랜잭션 자체가 존재하지 않으므로 트랜잭션을 커밋할 일이 없다 그리고 JPQL 쿼리도 트랜잭션 없이 실행하면 플러시를 호출하지 않는다.
    

⇒ 메모리 최적화를 위해선 스칼라 타입으로 조회하거나 하이버네이트가 제공하는 읽기 전용 쿼리 힌트를 사용하면 되고 플러시 호출을 막아서 속도를 최적화하려면 읽기 전용 트랜잭션을 사용하거나 트랜잭션 밖에서 읽기를 사용하면 된다. 참고로 스프링 프레임워크를 사용하면 읽기 전용 트랜잭션을 사용하는 것이 편리하다.

따라서 읽기 전용 트랜잭션(또는 트랜잭션 밖에서 읽기)과 읽기 전용 쿼리 힌트(또는 스칼라 타입으로 조회)를 동시에 사용하는 것이 가장 효과적이다.

### 배치 처리

수백만 건의 데이터를 배치 처리해야 하는 상황 → 엔티티 계속 조회 시 영속성 컨텍스트에 아주 많은 엔티티가 쌓이고 OOM 문제 발생 → 따라서 적절한 단위로 영속성 컨텍스트를 초기화 해야한다.

2차 캐시를 사용하고 있다면 2차 캐시에 엔티티를 보관하지 않도록 주의해야 한다.

- JPA 등록 배치
    
    적절하게 플러시 하고 영속성 컨텍스트 초기화해야함. → 안하면 OOM
    
    100마다 플러시하고 클리어하는 등의 적절한 처리해줘야함.
    
- JPA 수정 배치
    
    수많은 데이터를 한 번에 메모리에 올려둘 수 없어서 주로 2가지 방식 사용
    
    - 페이징 처리 : DB 페이징 기능 사용
    - 커서 : DB가 지원하는 커서 기능 사용

### JPA 페이징 패치 처리

- JPA 페이징 배치 처리
    - 페이지 단위마다 영속성 컨텍스트를 플러시하고 초기화한다.
- 하이버네이트 scroll 사용
    - JPA는 JDBC 커서를 지원하지 않아서 커서를 사용하려면 하이버네이트 세션을 사용해야 한다.
    - em.unwrap() 메소드를 사용해서 하이버네이트 세션을 구하고 쿼리를 조회하면서 scroll() 메소드로 scrollableResults 객체를 반환받고 next() 메소드를 호출하여 엔티티를 하나씩 조회한다.
- 하이버네이트 무상태 세션 사용
    - 하이버네이트는 무상태 세션이라는 특별한 기능을 제공하는데 이름 그대로 무상태 세션은 영속성 컨텍스트를 만들지 않고 심지어 2차 캐시도 사용하지 않는다. 무상태 세션은 영속성 컨텍스트가 없다. 그리고 엔티티 수정 시 무상태 세션이 제공하는 update() 메소드를 직접 호출해야 한다.
    - 이는 일반 하이버네이트 세션과 거의 비슷하지만 영속성 컨텍스트가 없다.
    - 따라서 영속성 컨텍스트를 플러시하거나 초기화하지 않아도 된다. 대신 엔티티 수정 시 update() 메소드를 직접 호출해야한다.

### SQL 쿼리 힌트 사용

JPA는 DB SQL 힌트 기능을 제공하지 않는다. SQL 힌트를 사용하려면 하이버네이트를 직접 사용해야 한다. (여기서의 SQL 힌트는 JPA 구현체에게 제공하는 힌트가 아닌 DB 벤더에게 제공하는 힌트이다.)

```java
Session session = em.unwrap(Session.class); // 하이버네이트 직접 사용

List<Member> list = session.createQuery("SELECT m FROM Member m")
			.addQueryHint("FULL (MEMBER) ") // SQL HINT 추가
			.list();
```

현재 하이버네이트엔 오라클 방언에만 힌트가 적용되어 있음. 다른 DB에서 이를 적용하기 위해선 Override를 통해 기능을 구현해야한다.

### 트랜잭션을 지원하는 쓰기 지연과 성능 최적화

트랜잭션을 지원하는 쓰기 지연을 활용해서 애플리케이션 성능을 최적화하는 방법을 알아보자.

- 트랜잭션을 지원하는 쓰기 지연과 JDBC 배치
    
    네트워크 호출 한 번은 단순한 메소드를 수만 번 호출하는 것보다 더 큰 비용이 든다. inset sql 5번을 보낸다고 가정하면 이는 5번의 sql과 1번의 커밋으로 DB와 통신하는데 이걸 최적화하기 위해선 5번의 sql을 한 번에 DB에 보내면 된다.
    
    JDBC가 제공하는 SQL 배치 기능을 사용하면 SQL,을 모아서 DB에 한번에 보낼 수 있다. 하지만 이 기능을 사용하려면 코드의 많은 부분을 수정해야 한다. 특히 비즈니스 로직이 복잡하게 얽혀 있는 곳에서 사용하기는 쉽지 않고 적용해도 코드가 상당히 지저분해진다. 그래서 보통 수백 수천 건 이상의 데이터를 변경하는 특수한 상황에 SQL 배치 기능을 사용한다.
    
- JPA는 플러시가 있어서 이를 사용하기 좋고 하이버네이트는 등록, 수정, 삭제 시 배치 기능을 이용한다. 배치 사이즈를 설정해주면 최대 그 크기만큼 모아서 실행한다. 이는 같은 sql일 때만 유효하다. 중간에 다른 처리가 들어가면 SQL 배치는 다시 시작한다.

### 트랜잭션을 지원하는 쓰기 지연과 애플리케이션 확장성

트랜잭션을 지원하는 쓰기 지연과 변경 감지 기능 덕분에 성능과 개발의 편의성이라는 두 마리 토끼를 모두 잡을 수 있었다. 하지만 진짜 장점은 DB 테이블 루우에 락이 걸리는 시간을 최소화 한다는 점이다.

이 기능은 트랜잭션을 커밋해서 영속성 컨텍스트를 플러시하기 전까지는 데이터베이스에 데이터를 등록, 수정, 삭제하지 않는다. 따라서 커밋 직전까지 데이터베이스 로우에 락을 걸지 않는다.

```java
update(memberA);
비즈니스로직A();
비즈니스로직B();
commit();
```

JPA를 사용하지 않고 SQL을 직접 다루면 update(memberA)를 호출할 때 UPDATE SQL을 실행하면서 DB 테이블 로우에 락을 건다. 이 락은 비즈니스 로직 A(), 비즈니스 로직B()를 모두 수행하고 commit()을 호출할 때까지 유지된다. 트랜잭션 격리 수준에 따라 다르지만 보통 많이 사용하는 커밋된 읽기 격리 수준이나 그 이상에서는 DB에 현재 수정 중인 데이터(로우)를 수정하려는 다른 트랜잭션은 락이 풀릴때까지 대기한다.

JPA는 커밋을 해야 플러시를 호출하고 DB에 수정 쿼리를 보낸다. 예제에서 commit()을 호출할 때 UPDATE SQL을 실행하고 바로 DB 트랜잭션을 커밋한다. 쿼리를 보내고 바로 트랜잭션을 커밋하고 결과적으로 데이터베이스에 락이 걸리는 시간을 최소화한다.

사용자가 증가하면 애플리케이션 서버를 더 증설하면 된다. 하지만 DB 락은 애플리케이션 서버 증설만으로는 해결할 수 없다. 오히려 애플리케이션 서버를 증설해서 트랜잭션이 증가할수록 더 많은 DB 락이 걸린다. JPA의 쓰기 지연 기능은 DB에 락이 걸리는 시간을 최소화해서 동시에 더 많은 트랜잭션을 처리할 수 있는 장점이 있다.

# 15.5 정리

- JPA의 예외는 롤백을 표시하는 예외와 아닌 예외로 나누고 롤백을 하는 예외는 심각한 예외이다.
- 스프링은 JPA 예외를 추상화한 예외로 변환해준다.
- 같은 영속성 컨텍스트의 엔티티는 동일성을 비교할 수 있지만 그렇지 않으면 불가하고 동등성을 비교해야한다.
- 프록시를 사용하는 클라이언트는 조회한 엔티티가 프록시인지 아니면 원본 엔티티인지 구분하지 않고 사용할 수 있어야 한다. 하지만 프록시는 기술적인 한계가 있으므로 한계점을 인식하고 사용해야 한다.
- JPA를 사용할 때는 N+1 문제를 가장 조심해야 한다. N+1 문제는 주로 페치 조인을 사용해서 해결한다.
- 엔티티를 읽기 전용으로 조회하면 스냅샷을 유지할 필요가 없고 영속성 컨텍스트 를 플러시하지 않아도 된다.
- 대량의 엔티티를 배치 처리하려면 적절한 시점에 꼭 플러시를 호출하고 영속성 컨텍스트도 초기화해야한다.
- JPA는 SQL 쿼리 힌트를 지원하지 않지만 하이버네이트 구현체를 사용하면 SQL 쿼리 힌트를 사용할 수 있다.
- 트랜잭션을 지원하는 쓰기 지연 덕분에 SQL 배치 기능을 사용할 수 있다.

다음 장에서는 트랜잭션과 락에 대해 알아보고 애플리케이션 레벨으 ㅣ캐시도 알아보자.
