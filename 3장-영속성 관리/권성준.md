## 3.1 엔티티 매니저 팩토리와 엔티티 매니저

- EntityMangagerFactory
    - 생성 비용이 매우 큼. 보통 데이터베이스 하나 당 하나 생성함.
    - 여러 스레드가 동시에 접근해도 안전함.
    
    ```java
    EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpa);
    ```
    

- EntityManager
    - **여러 스레드가 동시에 접근하면 동시성 문제 생김. 스레드 간 절대 공유 X**
    
    ```java
    EntityManager em = emf.createEntityManager();
    ```
    

1. 웹 어플리케이션에 EntityMangagerFactory 는 1개가 있다.
2. 사용자의 요청이 오면 EntityManager 를 생성해서 제공한다.
3. **EntityManager 는 데이터베이스 연결이 필요한 시점에 커넥션을 얻어서 사용한다.**
    1. ex) 트랜잭션 시작 시

## 3.2 영속성 컨텍스트란?

- **엔티티를 영구 저장하는 환경 → `엔티티를 관리하는 곳`** 이라고 이해하였음.
- EntityManger 를 통해서 영속성 컨텍스트에 접근, 관리가 가능함.

## 3.3 엔티티의 생명주기

- `비영속`: 영속성 컨텍스트와 전혀 관계가 없는 상태
    - 엔티티 객체를 생성만 한 상태. 영속성 컨텍스트나 DB 와는 전혀 연관되어 있지 않음.
    
    ```java
    Post post = new Post("제목", "내용"); // 비영속 상태임.
    ```
    

- `영속`: 영속성 컨텍스트에 저장된 상태
    - EntityManager 를 통해서 영속성 컨텍스트에 저장한 상태. ->영속성 컨텍스트가 관리하는 상태
- `준영속`: 영속성 컨텍스트에 저장되었다가 분리된 상태
    - 영속성 컨텍스트가 관리하던 엔티티를 관리하지 않게된 상태
    - detach(), close(), clear() 메서드로 준영속 상태로 만들 수 있음
- `삭제`: 삭제된 상태
    - 엔티티를 영속성 컨텍스트와 DB 에서 삭제함.

## 3.4 영속성 컨텍스트의 특징

- **반드시 식별자 값이 필요**
- **트랜잭션 커밋 시 DB 에 반영 (플러시)**

### 3.4.1 엔티티 조회

- 1차 캐시에서 조회
    - 영속 상태의 엔티티는 모두 1차 캐시에 보관
    - 식별자와 그에 대응하는 엔티티 인스턴스 형태로 보관
    - **조회 시 1차 캐시에서 먼저 찾고 없을 시에 DB 에서 조회함**
- DB 에서 조회
    - **조회 시 1차 캐시에 없으면 DB 에서 조회 후 1차 캐시에 저장, 그 후 사용자에게 반환**
- 동일성 보장
    - 영속되어 있는 엔티티는 같은 식별자를 가지면 1차 캐시에서 같은 인스턴스를 반환함.

### 3.4.2 엔티티 등록

- 쓰기 지연
    - EntityManager 는 트랜잭션 커밋 전까지 DB 에 반영하지 않고 내부 쓰기 지연 저장소에 INSERT 쿼리들을 저장해놓음.
        - 커밋 시 한번에 보냄
    - 트랜잭션 커밋 시 **영속성 컨텍스트 변경내용을 DB 에 동기화(플러시) 후 실제 DB트랜잭션 커밋함**
- 쓰기 지연이 가능한 이유
    - save() 메서드가 호출될 때마다 바로 DB 에 쿼리 보내는 경우
    - 메모리에 모든 등록 쿼리를 모아뒀다가 커밋 직전에 DB에 쿼리들 보내는 경우
    
    → **트랜잭션 범위 안에서 실행되므로 같은 결과를 가짐.**
    

### 3.4.3 엔티티 수정

- 변경 감지
    - update() 메서드가 필요 없음. **단순히 영속화된 엔티티를 변경해주면 됨.**
    - 영속화된 엔티티를 수정하면 바로 1차 캐시에서는 수정됨.
    - **스냅샷**을 이용
        - **엔티티가 영속화될 시 최초의 상태**를 스냅샷이라고 함.
        - 플러시(영속성 컨텍스트 변경내용을 DB 에 동기화**)** 시점에 스냅샷과 현재 1차 캐시의 상태를 비교하여 변경 감지.
    - 과정
        - 트랜잭션 커밋
        - EntityManager 가 플러시 호출
        - 스냅샷과 현재 상태 비교하여 변경 감지
        - 변경 내역 관련 쿼리를 쓰기 지연 저장소에 저장
        - 쓰기 지연 저장소에 있는 쿼리들을 DB 에 보냄
        - DB 트랜잭션 커밋
- 변경 감지로 실행된 UPDATE 쿼리 전략
    - **수정된 필드만 작성하지 않고 모든 필드를 업데이트 함.**
    - 장점
        - 쿼리가 항상 같음. 애플리케이션 로딩 시점에 쿼리 미리 생성 가능.
        - DB 에 같은 쿼리를 보낼 시 DB 캐시 사용 가능.
    - @org.hibernae.annotations.DynamicUpdate 사용 시 수정된 데이터만 업데이트 가능.
    - 보통 필드가 30개 이상 되면 DynamicUpdate 가 나음.
    

### 3.4.4 엔티티 삭제

- remove() 에 삭제할 엔티티를 넘겨주면 삭제함.
- remove() 호출 시 바로 영속성 컨텍스트에서 삭제됨.
- 등록과 비슷하게 `삭제 쿼리 쓰기 지연 저장소로 보냄 → 트랜잭션 커밋 → 플러시 호출 → 쓰기 지연 저장소 쿼리들 DB 에 보냄 → DB 트랜잭션 커밋` 과정을 거쳐 적용됨.

## 3.5 플러시

- 영속성 컨텍스트의 변경 내용을 DB 에 동기화하는 것
- 플러시 호출 시 과정
    - 변경 감지 동작하여서 스냅샷과 현재 영속성 컨텍스트의 상태를 비교
    - 수정된 엔티티에 대한 수정 쿼리를 쓰기 지연 저장소에 보냄
    - 쓰기 지연 저장소에 있는 쿼리들을 DB 에 보냄
- 플러시 호출 방법
    - flush() 메서드 호출
    - 트랜잭션 커밋 시 자동 호출
        - 플러시가 선행되지 않으면 DB 반영 안됨.
    - JPQL 쿼리 실행 시 자동 호출
        
        ```java
        em.persist(postA);
        em.persist(postB);
        em.persist(postC);
        
        Query query = em.createQuery("select p from Post p"), Post.class);
        List<Post> posts = query.getResultList();
        ```
        
        - postA, postB, postC 는 영속성 컨텍스트에는 있지만 DB 에는 없음.
        - JPQL 은 SQL 로 변환되어 DB 에서 조회하는데, 플러시가 선행되지 않으면 postA, postB, postC 를 조회할 수 없음.
        

## 3.6 준영속

- 영속성 컨텍스트에서 제거된 상태 → **1차 캐시(스냅샷 포함), 쓰기 지연 저장소에서도 제거**
- 영속화된 엔티티를 준영속화하면 순수 Java 객체됨.
- 영속성 상태에서 제공되는 기능을 사용할 수 없음
- 준영속 상태로 만드는 방법
    - detach() 메서드 호출
        - 특정 엔티티를 준영속화
    - clear() 메서드 호출
        - 모든 엔티티를 준영속화
    - close() 메서드 호출
- 특징
    - 거의 비영속 상태임
        - 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩 등 영속성 컨텍스트 관련 기능을 아무것도 사용 못함
    - 식별자 값을 가짐
        - 영속화 되었다가 준영속된 것이므로 식별자 값은 가짐.
    - 지연 로딩 불가
        - 지연 로딩은 **실제 객체 대신 프록시 객체를 로딩해두고 실제 사용 시 영속성 컨텍스트에서 불러오는 방식**
        - 영속성 컨텍스트에서 관리하지 않으므로 사용 불가능
- 다시 영속화하는 방법
    - merge() 메서드 호출 → 비영속 or 준영속 엔티티를 받아서 새로운 영속 엔티티 반환
    - 준영속되었던 엔티티가 변경되는 것이 아님. 영속화된 새로운 엔티티를 반환하는 것임.
    - 과정
        - merge() 호출
        - 입력된 비영속 or 준영속 엔티티의 식별자로 1차 캐시에서 조회
        - 1차 캐시에 없으면 DB 에서 조회 후 1차 캐시에 영속 엔티티 저장
            - DB 에도 없으면 새로운 엔티티 만들어서 영속화함.
        - 1차 캐시에 저장된 영속 엔티티에 준영속 엔티티의 값을 밀어넣음
        - 영속 엔티티를 반환
