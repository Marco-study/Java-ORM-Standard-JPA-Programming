# 3장 영속성 관리

JPA가 제공하는 기능 크게 2개로 나눌 수 있음.

1. 엔티티와 테이블을 매핑하는 설계부분
2. **매핑한 엔티티를 실제 사용하는 부분**

3장에선 두번째 기능인 매핑한 엔티티를 엔티티 매니저를 통해서 어떻게 사용하는지 알아보자.

DB를 하나만 사용하는 애플리케이션 → 일반적으로 하나의 EntityManagerFactory 공유해서 사용.

⇒ EntityManagerFactory를 생성하는 비용이 굉장히 크기 때문.

이를 생성하기 위한 정보를 META-INF/persistence.xml 파일에서 가져오는데 DB Driver, username, password, url 등의 정보를 받아옴.

이 EntityManagerFactory는 EntityManager를 생산하는데 이는 비용이 굉장히 작음.

그래서 요청마다 하나의 EntityManager를 생성함.

EntityManagerFactory는 thread safe 하기 때문에 여러 스레드에서 공유하여 사용할 수 있지만 EntityManger는 그렇지 않기에 스레드간 공유를 절대하면 안됨.

이 EntityManager는 엔티티에 관한 CRUD 등의 관리를 하는 기능을 담당하고 있음 (가게 매니저 같은 느낌.)

생성 시 data pool에 있는 커넥션 하나를 가지고 와서 DB와 연결됨.

저런 data pool에 관한 정보들을 J2SE에서는 persistence.xml과 같은 파일을 이용했지만 J2EE 환경에서는 해당 프레임워크의 컨테이너가 생성하는 data source를 이용함.

- J2SE : 기본적 핵심 Java 클래스를 포함하는 Java 2 Standard Edition이고 대부분의 사람들이 표준 애플릿과 응용 프로그램을 작성하는데 사용한다.
- J2EE : Java 2 Enterprise Edition이며 J2SE 이상의 클래스를 포함함. 실제로 J2EE에서 많은 클래스를 사용하려면 J2SE가 필요함. J2EE가 제공하는 것 중 일부는 서블릿 및 EJB와 같은 서버측 클래스임. 또한 Security API, Jaba Mail API, XML Parser 등 Java Messaging Service API 및 기타 몇가지가 포함되어 있음. 이러한 API 중 일부는 새로운 J2SE 1.4 번전에 포함되었으며 이젠 표준으로 간주됨. XML API가 이런 예이다.
- J2ME : 팜 파일럿이나 휴대폰과 같은 휴대용 장치에 코딩하는 개발자를 위한 것. 이런 장치의 코드는 크기가 작아야 하고 메모리를 적게 차지해야 함. 따라서 PDA용으로 코딩하는 경우 J2ME를 사용하고 싶을 것.

---

# 영속성 컨텍스트

JPA를 이해하는데 가장 중요한 용어임.

영속성 컨텍스트 : **엔티티를 영구 저장하는 환경**

영속성 컨텍스트는 **엔티티 매니저를 생성**할 때 하나 만들어짐. 그리고 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고 관리할 수 있음.

## 엔티티 생명주기

- 비영속 상태 (new) : 영속성 컨텍스트와 전혀 연관없는 상태
    - 순수한 자바 객체 상태를 의미.
- 영속 상태 (managed) : 영속성 컨텍스트에 저장된 상태
    - 영속 상태 → 영속성 컨텍스트가 관리하는 상태
- 준영속 상태 (detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
    - detached()를 통해 엔티티를 준영속 상태로 바꾸거나 close()를 통해 영속성 컨텍스트를 닫거나 clear()를 통해 영속성 컨텍스트를 초기화하는 경우 영속 상태의 엔티티가 준영속 상태가 됨.
- 삭제 상태 (removed) : 영속성 컨텍스트와 DB에서 삭제한 상태.

## 영속성 컨텍스트의 특징

- 영속성 컨텍스트에서 엔티티를 구분하기 위해서 식별자 값을 사용함. → @Id를 붙여서 식별자 값에 매핑시킨 컬럼이 없는 경우엔 예외 발생
- 언제 DB에 엔티티가 저장될까? → 트랜잭션의 커밋 시점에서 flush() 수행 시에 DB에 반영됨.

영속성 컨텍스트가 엔티티를 관리할 시 다음과 같은 장점이 존재함.

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

### 엔티티 조회

영속성 컨텍스트에서 엔티티를 관리할 때 조회에서 발생하는 이점이 있음.

- 바로 1차 캐시. 1차 캐시란 영속성 컨텍스트 내부에 존재하는 Map과 같은 녀석이라고 생각을 하고 key는 식별자 값, value가 엔티티 인스턴스.
    
    엔티티 조회 시에 영속성 컨텍스트는 우선적으로 내부에 존재하는 1차 캐시에서 찾아봄. 없는 경우에 DB에 조회를 함.
    
    DB에서 조회하게 되는 경우엔 먼저 찾아온 정보를 통해서 엔티티를 생성하고 이를 1차 캐시에 저장하면서 영속 상태로 만든 후에 이를 반환해줌. 그럼 이후부터 조회를 요청하게 되면 1차 캐시에 있는 값을 주게 되니까 **성능적으로 이점이 생김.**
    
- 다른 이점은 동일성 보장임. 조회하는 메소드를 반복해서 호출해도 1차 캐시에 존재하면 똑같은 인스턴스를 내려주게 됨. → 이는 동일성을 보장하게 됨.
    
    ⇒ 그리고 1차 캐시를 통해서 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 애플리케이션 차원에서 제공한다는 점이 장점.
    

⇒ 근데 동등성은 보장안해줌 → 이는 equals를 통해서 구현해야하고 entity에서 equals 구현 시 주의할 점은 영속성 컨텍스트에서 엔티티를 구분하기 위해서 식별자 값만을 사용하기에 해당 컬럼만을 이용해서 equals와 hashcode를 생성하는 것이 좋음.

⇒ 내부적으로 어떤 식으로 동작하는지 모르는 롬복의 @EqualsAndHashcode는 엔티티에서 사용하지 않는 것이 좋아보임.

### 엔티티 등록

엔티티 등록 시에도 장점이 존재함.

- 바로 쓰기 지연. 쓰기 지연이란 말그대로 DB에 값을 쓰는 것을 지연 시키는 것. 영속성 컨텍스트 내부에 쓰기 지연 SQL 저장소가 존재함. 아무리 데이터를 많이 저장해봤자 트랜잭션 커밋을 안하면 무용지물 → 쓰기 지연 SQL 저장소에 등록, 삭제, 수정 SQL을 저장해놓고 트랜잭션 커밋 시점에 이 SQL을 전부 flush하는 것. 커밋이 되기 전에 먼저 SQL flush()를 전부 수행함. ⇒ 성능적으로 이점이 생김.

### 엔티티 수정

SQL 수정 쿼리에는 문제점이 있음. 그건 바로 수정 쿼리가 엄청 많이 필요하다는 문제점.

모든 필드를 수정하는 쿼리하나만 두면 좋겠지만 이는 실수로 데이터가 저장되지 않는 경우가 발생할 수 있기에 부담스러운 상황을 피하기 위해서 개별적 수정 SQL을 짜게 됨. 이것의 문제점은 비즈니스 로직을 파악하기 위해선 결국 SQL을 봐야한다는 점임. → 이는 비즈니스 로직이 직접적이든 간접적이든 SQL에 종속된다 (의존한다)라는 의미임.

- 그래서 JPA에서는 이를 변경감지, dirty checking을 통해서 해결함. 변경감지는 엔티티의 flush 시점에서 엔티티의 최초 상태(스냅샷)와 현재 상태를 비교함. 1차 캐시를 보면서 비교해서 다르면 UPDATE 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보내고 이 SQL들을 전부 반영함. → 변경감지는 1차 캐시를 찾아본다라고 했는 것처럼 영속 상태인 엔티티에만 적용되는 기능임.
    
    ⇒ 추가적으로 변경감지는 기본적으로 모든 필드를 수정하는 UPDATE문을 짬. → 중복적인 SQL이 필요없고 애플리케이션 로딩 시점에서 이를 미리 생성해놓고 재사용이 가능하다는 장점 때문.
    
    ⇒ 만약 필드가 너무 많거나 필드 데이터 값이 너무 큰 경우엔 특정 필드만 UPDATE하는 쿼리를 생성할 수 있음. 하지만 이는 하이버네이트의 확장 기능을 이용해야 하고 특정 구현체에 종속될 수 있음. → 기본적으로 지원하는 모든 필드를 수정하는 UPDATE SQL을 사용하지만 이를 사용했을 때 너무 성능이 안나오는 경우 전략을 수정.
    

### 엔티티 삭제

위에서 언급했듯 엔티티 삭제시에도 쓰기 지연을 이용함. remove() 메소드 사용 시에 DB에 반영되지는 않지만 영속성 컨텍스트에서는 삭제됨. 그래서 해당 인스턴스를 사용하지 않고 GC에 의해서 자연스럽게 할당해제되도록 만들어줄 필요가 있음.

---

# 플러시

flush() : 영속성 컨텍스트의 변경 내용을 DB에 반영함. 구체적으로는 아래와 같은 일이 일어남.

1. 변경감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
2. 쓰기 지연 SQL 저장소의 쿼리를 DB에 전송한다. (등록, 수정, 삭제 쿼리)

영속성 컨텍스트를 플러시하는 방법은 총 3가지이다.

1. em.flush()를 직접 호출
    1. 메소드 호출을 통해 영속성 컨텍스트를 강제로 플러시함. 테스트나 다른 프레임워크와 JPA를 함께 사용할 때 외에는 거의 사용하지 않음.
2. 트랜잭션 커밋 시 플러시 자동 호출
    1. DB에 변경 내용을 SQL로 전달하지 않고 트랜잭션 커밋만 한다면 아무런 변화도 없음. 따라서 트랜잭션 커밋전에 flush()가 필요함. → 그래서 커밋 시 자동으로 플러시를 호출함.
3. JPQL 쿼리 실행 시 플러시 자동 호출.
    1. JPQL이나 Criteria 같은 객체지향 쿼리를 호출할 때도 플러시가 실행됨.
        
        → 왜? 만약 persist를 통해서 엔티티를 1차 캐시엔 저장했는데 그 때 갑자기 JPQL을 이용해서 엔티티를 DB에서 조회하면 조회결과가 없다고 나옴. 그래서 이를 방지하기 위해서 JPQL 쿼리를 던지기 전에 flush를 선행함.
        
        ⇒ 쿼리나 커밋을 진행할 때 플러시를 하는 것이 기본 값인데 이를 변경할 수 있음. javax.persistence.FlushModeType을 이용하면 되는데 AUTO는 기본 값은 쿼리나 커밋 진행 시 플러시를 하는 것이고 COMMIT 모드는 커밋 시에만 플러시를 선행함.
        

# 준영속

이때까지는 비영속 → 영속 → 삭제 상태 변환을 설명했으면 이제는 영속 → 준영속 상태 변환에 대해서 설명해보자.

영속 상태를 준영속 상태로 바꾸는 방법은 총 3가지 이다.

1. em.detach(entity) : 특정 엔티티를 준영속 상태로 전환.
    - 이는 영속성 컨텍스트에게 더 이상 이 엔티티를 관리하지 말라고 하는 것.
    - 메소드 호출 시 1차 캐시, 쓰기 지연 SQL 저장소의 정보 다 삭제됨.
    
    ⇒ 해당 엔티티는 DB에 반영안됨.
    
2. em.clear() : 영속성 컨텍스트를 완전히 초기화함.
    - 말그대로 완전히 초기화 → 영속 상태 모든 엔티티를 전부 준영속 상태로 전환.
    - 그냥 영속성 컨텍스트를 새롭게 만든 것과 동일함.
3. em.close() : 영속성 컨텍스트를 종료함.
    - 이것도 말그대로 영속성 컨텍스트를 종료 → 마찬가지로 모든 엔티티 전부 준영속.

⇒ 얘네 전부 영속성 컨텍스트의 기능을 아예 사용할 수 없음.

### 준영속 상태의 특징

- 거의 비영속에 가까움
- 식별자 값을 가지고 있음 → 영속 상태였다보니까 식별자 값을 가짐.
- 지연 로딩을 할 수 없음. → 이는 영속성 컨텍스트의 기능이니까 준영속 상태의 엔티티가 이용할 수 없음.

### 병합 : merge()

위에서 영속 상태를 준영속으로 바꾸는 방법에 대해서 알아봤다면 이제는 반대로 준영속 상태를 영속상태로 다시 전환하는 방법에 대해서 알아봄.

merge() 메소드를 이용하면 되는데 해당 메소드는 준영속 상태의 엔티티를 받아서 그 정보로 완전히 새로운 영속 상태의 엔티티를 반환함.

1. 먼저 영속성 상태로 만들어서 DB에 저장하고 나서 영속성 컨텍스트가 종료되었다고 생각하자. → 그럼 결국 현재 엔티티는 준영속 상태이다.
2. 이때, 준영속 상태의 엔티티의 필드 값을 바꾼다. → 그럼 변경 감지 기능을 이용할 수 없음.
3. 이 후에 merge를 통해서 해당 준영속 상태의 엔티티를 영속 상태로 바꾼다고 생각하자.
4. 그러면 merge는 위에 말했듯이 완전히 새로운 엔티티 인스턴스를 반환하는데 파라미터로 들어온 준영속 상태의 엔티티는 두고 1차 캐시와 DB에 해당 엔티티가 존재하는지 조회한다. 그리고 1차 캐시에 반영하고 나서 파라미터로 들어온 엔티티의 정보를 1차 캐시에 존재하는 인스턴스에 카피하고 반환한다. (모든 필드값을 1차캐시의 인스턴스로 밀어넣음.) → 이러면 완전 새로운 엔티티 인스턴스가 생긴 것이고 아까 준영속 상태에서 바꿨던 필드 값도 반영됨.
5. 그러면 이 반환된 엔티티만 영속 상태고 파라미터로 넣었던 엔티티는 여전히 준영속이기에 반환된 인스턴스를 이용해야함.
- 그럼 비영속 상태의 엔티티를 merge하면 어떻게 될까? 똑같다. 1차 캐시, DB에서 조회하고 없어도 새로운 영속 상태의 엔티티 인스턴스를 이번엔 생성해서 반환한다. (물론 파라미터로 들어온 비영속 상태의 엔티티의 필드 값을 다 밀어넣음.)
- 그래서 save and update 같이 존재해도 안존재해도 새로운 영속 상태의 엔티티 인스턴를 반환한다.
