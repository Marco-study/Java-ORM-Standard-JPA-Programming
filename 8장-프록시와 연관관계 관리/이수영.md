# 8장 프록시와 연관관계 관리

객체가 DB에 저장되어 있어 객체 그래프이 어려움. 그래서 **프록시**라는 기술 사용.

실제 사용하는 시점에 DB 조회 But 자주 함께 사용 시 조인을 사용하는게 효과적.

⇒ 즉시 로딩, 지연 로딩 모두 지원

## 8.1 프록시

특정 엔티티의 연관된 엔티티를 전혀 사용하지 않는 경우가 존재하고 이 경우 연관도니 엔티티를 함께 조회하는 것은 효율적이지 않다. → 이 문제 해결하기 위해 **지연 로딩** 이용

실제 엔티티 값을 사용하는 시점에 조회하는 것. 이를 이용하기 위해선 실제 엔티티를 대신해 조회를 지연할 수 있는 가짜 객체 필요 → **프록시 객체**

### 8.1.1 프록시 기초

EntityManager.getReference 메소드 이용 → 엔티티 값을 실제 사용하는 시점까지 조회 미룸.

해당 메소드 이용 → JPA는 DB 조회 X, 실제 엔티티 객체 생성도 X 대신 DB 접근을 위임한 프록시 객체 반환.

- **프록시 특징**
    - 프록시 객체는 실제 객체에 대한 참조를 보관함.
    - 프록시 객체의 메소드를 호출 시 프록시 객체는 실제 객체의 메소드를 호출함.
    - 프록시 객체 처음 사용 시 한번만 초기화
    - 타입 체크 시에 주의해서 사용.
    - 이미 엔티티가 영속성 컨텍스트에 존재 → DB 조회 필요없음 → getReference를 호출해도 실제 엔티티 반환.
    - 초기화는 영속성 컨텍스트의 도움을 받아 가능. → 준영속 상태의 프록시 초기화 시 문제 발생(LazyInitializationException 발생)
- **프록시 객체의 초기화**
    - 프록시 객체가 실제 사용될 때 DB 조회를 해서 실제 엔티티 객체를 생성 → **프록시 초기화**
- **프록시 초기화 과정**
    1. 프록시 객체의 실제 값 호출 시 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성 요청 → **초기화**
    2. 영속성 컨텍스트는 DB 조회 → 실제 엔티티 객체 생성
    3. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 엔티 멤버변수에 보관.
    4. 프록시 객체는 실제 엔티티 객체의 메소드 호출을 통해 결과 반환.

### 8.1.2 프록시와 식별자

@Access(AccessType.PROPERTY) 설정 → getId() 호출해도 프록시 초기화 X

@Access(AccessType.FIELD) 설정 → getId() 호출 시 프록시 초기화 O

⇒ 연관관계 설정 시에 식별자 값만 사용 → 프록시 사용으로 DB 접근 횟수 줄이기 가능. (필드로 해도 프록시 초기화 X)

### 8.1.3 프록시 확인

PersistenceUnitUtil.isLoaded(Object entity) 메소드를 사용하여 프록시 인스턴스의 초기화 여부 확인 가능. → 이미 초기화되었거나 프록시 인스턴스가 아니면 true 반환.

## 8.2 즉시 로딩과 지연 로딩

- 즉시 로딩 : 엔티티 조회 시 연관된 엔티티도 함께 조회
- 지연 로딩 : 연관된 엔티티를 실제사용 시 조회

### 8.2.1 즉시 로딩

@ManyToOne fetch 속성을 FetchType.EAGER로 지정.

이는 **즉시 로딩을 최적화하기 위해 가능하면 조인쿼리를 사용.**

여기서 null 제약 조건을 안걸어주면 outer join 사용. → @JoinColumn이나 @ManyToOne 어노테이션에 null 제약 걸어줌. → 그럼 inner join 이용.

### 8.2.2 지연 로딩

@ManyToOne fetch 속성을 FetchType.LAZY로 지정.

실제 데이터가 필요한 순간에 프록시 객체 초기화 → SQL 실행됨.

### 8.2.3 즉시 로딩, 지연 로딩 정리

만약에 특정 엔티티와 연관 엔티티의 정보를 같이 많이 사용한다면 SQL 조인을 사용해서 한번에 조회하는 것이 효율적임. → 즉시 로딩하는 것이 좋음.

반대라면 지연 로딩하는 것이 좋음.

## 8.3 지연 로딩 활용

### 8.3.1 프록시와 컬렉션 래퍼

하이버네이트 엔티티 영속 상태로 만들 때 컬렉션이 있으면 원본 컬렉션을 추적, 관리 목적으로 하이버 네이트가 제공하는 내장 컬렉션으로 변경 → 컬렉션 래퍼

### 8.3.2 JPA 기본 페치 전략

- @ManyToOne, @OneToOne → 가져올게 하나라서 EAGER
- @ManyMany, @OneToMany → 가져올게 많아서 LAZY

추천 방법은 모든 연관관계 → LAZY → 개발이 완료 단계에 왔을때 꼭 필욯나 곳만 즉시 로딩 이용.

SQL을 직접 사용 → 유연한 최적화가 어려움.

### 8.3.3 컬렉션에 FetchType.EAGER 사용 시 주의점

- **컬렉션 하나 이상 즉시 로딩하는 것은 권장 X**
    
    A 테이블을 N, M 두 테이블과 일대다 조인하면 SQL 결과가 N * M 해서 너무 많은 데이터를 반환할 수 있고 결국 성능이 저하됨.
    
- **컬렉션 즉시 로딩은 항상 외부 조인 사용.**

## 8.4 영속성 전이 : CASCADE

특정 엔티티를 영속 상태로 만들 떄 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이 기능 이용. → 부모 엔티티 저장 시 자식 엔티티도 함께 저장 가능.

JPA에서 엔티티 저장 시 연관된 모든 엔티티는 영속 상태여야함.

그래서 부모 엔티티를 영속 상태로 만들고 자식 엔티티도 각각 영속 상태로 만드는 경우 존재.

⇒ 이럴 때 영속성 전이 이용. ( 부모만 영속 상태 → 연관도니 자식도 한번에 영속 상태로 변환가능)

### 8.4.1 영속성 전이 : 저장

cascade = CascadeType.PERSIST 옵션 설정 → 부모 영속화 시 연관된 자식들도 함께 영속화.

이는 연관관계 매핑과는 아무 관련 X. 단지 엔티티를 영속화 시 연관된 엔티티도 같이 영속화하는 편리함 제공.

### 8.4.2 영속성 전이 : 삭제

cascade = CascadeType.REMOVE 옵션 설정 → 부모 엔티티 삭제 → 연관도니 자식 엔티티도 함께 삭제

⇒ 삭제 시 외래 키 제약조건을 고려 → 자식 먼저 삭제 후 부모 삭제.

만약 영속성 전이 없이 부모 엔티티 삭제 시 부모만 삭제됨 → 외래키 무결성 예외 발생함.

PERSIST, REMOVE는 persist(), remove() 실행 시 바로 전이가 발생하지 않고 플러시 호출 시 전이가 발생함.

## 8.5 고아 객체

부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능 제공 → 고아 객체 제거.

부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제됨.

컬렉션에 orphanRemoval = true 설정.

**고아 객체 제거 기능**은 영속성 컨텍스트를 **플러시할 때 적용**되므로 **플러시 시점**에 DELETE SQL이 실행됨.

**참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능.**

부모를 제거하면 자식도 같이 제거됨.

## 8.6 영속성 전이 + 고아 객체, 생명주기

CascadeType.ALL + orphanRemoval = true를 동시 사용 시 어떻게 될까?

일반적으로 엔티티는 persist를 통해 영속화되고 remove를 통해 제거 된다. → 이는 생명주기를 엔티티 본인 스스로 관리한다는 의미 인데 이렇게 설정하면 부모 엔티티가 자식 엔티티의 생명주기를 관리할 수 있게 된다.

⇒ 자식 저장 시 부모에 등록만 하면 됨. 자식 삭제시 부모에서 제거만 하면 됨.
