# 7장 고급 매핑

## 7.1 상속 관계 매핑

상속 관계를 매핑하는 방법으로 3가지를 이용할 수 있음.

1. 각각의 테이블로 변환 : 부모, 자식 엔티티를 전부 각각의 테이블로 만들고 조회할 때 조인을 이용함. (조인 전략)
2. 통합 테이블로 변환 : 부모, 자식 엔티티를 전부 하나의 테이블에서 통합해서 사용. (단일 테이블 전략)
3. 서브타입 테이블로 변환 : 서브 타입마다 하나의 테이블을 만듦 (구현 클래스마다 테이블 전략)

### 7.1.1 조인 전략

엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키 (식별 관계)로 이용하는 전략. (조회 시 조인을 자주 사용)

주의할 점은 객체는 타입으로 구분할 수 있는데 테이블은 타입의 개념이 없음. → 타입 구분 컬럼이 필요.

1. @Inheritance(InheritanceType.JOINED) 이용
2. @DiscriminatorColumn(name = “DTYPE”) → default가 DTYPE
3. @DiscriminatorValue(”각 엔티티마다 구분할 컬럼에 대한 값 추가.”)

- 장점
    - 테이블 정규화
    - 외래 키 참조 무결성 제약조건 활용 가능.
    - 저장공간 효율적으로 이용
- 단점
    - 조회 시 조인 많이 사용 → 성능 저하, 조회 쿼리 복잡
    - 데이터 등록 시, INSERT문 두번 실행.

### 7.1.2 단일 테이블 전략

이름 그대로 하나의 테이블에 모든 컬럼 넣음. → 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 함.

조인을 사용하지 않아 빠르고 구분컬럼 (DTYPE)으로 구분함.

1. @Inheritance(InheritanceType.SINGLE_TABLE) dldyd
2. 구분 컬럼 필수로 사용해야함.

- 장점
    - 조인 X → 성능 빠름, 쿼리 단순
- 단점
    - 자식 엔티티가 매핑한 컬럼 모두 null 허용
    - 단일 테이블에 모든 것 저장 → 테이블 커짐 → 조회 성능이 오히려 느려질 수 있음.
- 특징
    - 구분 컬럼 꼭 사용. → @DiscriminatorColumn 꼭 사용.

### 7.1.3 구현 클래스마다 테이블 전략

구현 클래스 마다 테이블 전략을 사용함 → 자식 엔티티마다 테이블을 만듦. → 추천하지 않음.

- 장점
    - 서브 타입을 구분해서 처리 시 효과적.
    - not null 제약조건을 사용할 수 있음.
- 단점
    - 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION 사용해야함.)
    - 자식 테이블 통합 쿼리가 어려움.
- 특징
    - 구분 컬럼 사용 X

## 7.2 @MappedSuperclass

이전에 설명했던 방법들은 테이블과 매핑을 했지만 이는 부모 클래스는 테이블 매핑없이 상속 받는 자식 클래스에게 매핑 정보만 제공하는 방식.

⇒ 실제 테이블과 매핑되지 않음. → 단순 매핑 정보 상속 목적.

1. @MappedSuperClass을 추상 클래스에 선언.
2. 이를 자식 클래스에서 구현.

- @AttributeOverride, @AttributeOverrides  → 상속받은 매핑 정보 재정의 가능.
- @AssociationOverride, @AssociationOverrides → 연관관계 재정의 가능.

이는 엔티티가 아니라서 부모 클래스를 영속성 컨텍스트를 이용해서 찾을 수 없음.

직접 생성해서 사용할 일은 거의 없기에 추상 클래스로 만드는 것을 권장함.

## 7.3 복합 키와 식별 관계 매핑

### 7.3.1 식별 관계 vs 비식별 관계

- 식별 관계 : 부모 테이블의 기본 키를 자식 테이블의 기본 키와 외래 키로 동시에 사용하는 관계.
- 비식별 관계 : 부모 테이블의 기본 키를 자식 테이블의 외래 키로만 사용하는 관계.
    - 필수적 비식별 관계 : 외래 키에 null 허용 X
    - 선택적 비식별 관계 : 외래 키에 null 허용

→ 주로 비식별 관계 이용하고 꼭 필요한 곳에만 식별 관계를 이용하는 추세.

### 7.3.2 복합 키 : 비식별 관계 매핑

- @IdClass
    1. @IdClass(ParentId.class) → 복합 키 매핑을 위한 식별자 클래스
    
    해당 어노테이션 사용 시 식별자 클래스는 다음 조건을 만족해야함.
    
    - 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야함.
    - Serializable 인터페이스를 구현해야함.
    - equals, hashCode 구현
    - 기본 생성자 필요.
    - 식별자 클래스 접근 지정자 public
    
    ```java
    Parent parent = new Parent();
    parent.setId1("id1");
    parent.setId2("id2");
    em.persist(parent);
    // 이렇게 하면 엔티티 등록직전에 내부에서 식별자 클래스인 ParentId를 생성하고
    // 영속성 컨텍스트의 키로 사용./
    ```
    
    조회 시엔 식별자 클래스를 이용해서 조회.
    
    - @JoinColumn로 각각의 외래 키 컬럼을 매핑하고  @JoinColumns로 복합  키 매핑.
- @EmbeddedId
    - 좀 더 객체지향적인 방법.
    - @Embeddable을 식별자 클래스에 달고 이를 이용하는 엔티티에 해당 어노테이션을 달고 식별자 클래스를 바로 사용.
    
    해당 어노테이션 사용 시 식별자 클래스는 다음 조건을 만족해야함.
    
    - @Embeddable ,붙이기
    - Serializable 인터페이스를 구현해야함.
    - equals, hashCode 구현
    - 기본 생성자 필요.
    - 식별자 클래스 접근 지정자 public

- 복합 키와 equals(), hashCode()
    - 마찬가지로 복합 키 식별자 클래스는 자바 코드이고 클래스이다. 인스턴스 간의 동등성을 확인하기 위해서 필요하다. →  JPA에선 해당 클래스 인스턴스를 이용해서 데이터를 찾을 테니까 무조건 필요함.
- @IdClass vs @EmbeddedId
    - 각각의 장단점이 있어 취향에 마즌 것을 일관성 있게 사용하면 된다.
    - @EmbeddedId가 더 객체 지향적이고 중복도 없어서 좋아보이긴 하지만 특정 상황에 JPQL이 더 길어질 수 있다.

### 7.3.3 복합 키: 식별 관계 매핑

식별 관계 매핑이니까 부모의 기본 키를 자식 테이블의 기본 키 + 외래 키 둘 다로 이용하는 방법이다.

그니까 점점 더 식별자 클래스가 커질 것이다. 부모 테이블 키가 parentId 였다고 치면 그 자식은 parentId와 childId를 복합 키로 식별자 클래스로 만들 것이다. 그럼 그 자식의 자식은 parentId, chidId, grandChildId를 필드로 가지는 식별자 클래스가 기본 키가 되는 것이다.

- @EmbeddedId는 식별 관계로 사용할 연관관계의 속성에 @MapsId를 사용하면 된다.
    
    @IdClass와 차이점이 @Id를 사용하지 않고 @MapsId를 이용한 것이다. → 이는 외래 키와 매핑한 연관관계를 기본 키에도 매핑하겠다는 뜻이다.
    

### 7.3.4 비식별 관계로 구현

복합 키 코드와 비교하면 매핑도 쉽고 코드도 단순하다. 그리고 복합 키 식별자 클래스를 만들지 않아도 된다.

### 7.3.5 일대일 식별 관계

일대일 식별 관계는 자식 테이블의 기본 키 값으로 부모 테이블 기본 키값만 사용한다. 그래서 부모 테이블이 기본 키가 복합 키가 아니라면 자식 테이블의 기본 키는 복합 키로 구성하지 않아도 된다.

단순히 컬럼 하나만 @MapsId를 사용하고 속성 값은 비워두면 된다. → @MapsId는 @Id를 사용해서 식별자로 지정한 필드 값과 매핑된다.

### 7.3.6 식별, 비식별 관계의 장단점.

DB 설계 관점에서 비식별 관계를 더 선호하는 이유는

1. 부모 테이블의 기본 키를 자식 테이블로 전파하면서 자식 테이블의 기본 키 컬럼이 점점 늘어난다. → 조인 시 SQL이 복잡해지고 기본 키 인덱스가 불필요하게 커질 수 있다.
2. 식별 관계는 2개 이상으 ㅣ컬럼을 합해서 복합 키존 키를 만들어야 하는 경우가 많다.
3. 요구 사항이 변하면 식별 관계의 자연 키컬럼들이 자식에 손자까지 전파되면서 변경이 어려워진다.
4. 테이블 구조가 유연하지 못하다.
5. JPA는 @GeneratedValue와 같은 대리 키를 쉽게 생성할 수 있는 방법을 제공한다.

물론 장점도 있는데 기본 키 인덱스를 활용하기 좋고 특정 상황에 조인 없이 하위 테이블만으로 검색을 완료할 수 있다.

⇒ 그냥 비식별 관계를 사용하여 기본 키는 Long 타입의 대리 키를 사용하자.

그리고 선택적보다 필수적 비식별 관계를 사용하는 것이 좋은데 선택적은 조인 시 외부 조인을 사용해야 한다 반면 필수적 관계는 내부 조인만 사용해도 된다. 

⇒ 외부 조인보다 내부조인을 선호하는 이유??

## 7.4 조인 테이블

DB에서 연관관계를 설계하는 방법은 크게 2가지 이다.

1. 조인 컬럼 사용 (외래 키)
2. 조인 테이블 사용 (테이블 사용)

- 조인 컬럼 사용 : 외래 키 컬럼을 사용해서 관리
- 조인 테이블 사용 : 별도의 테이블을 사용해서 연관관계를 관리.
    - 단순히 외래 키 컬럼만 추가하는게 아니라 테이블을 사용해서 연관관계를 관리하는 조인 테이블을 추가하고 여기서 두 테이블의 외래 키를 가지고 연관관계를 관리.
    
    → 각 테이블엔 외래 키 컬럼이 없음.
    
    → 큰 단점이 추가적인 테이블이 필요하다는 것이다. → 관리할 테이블이 늘어나고 두 테이블을 조인하려면 조인 테이블까지 추가로 조인해야한다.
    
    ⇒ 기본적으론 조인 컬럼을 사용하고 필요하다고 판단될 시 조인 테이블을 사용하자. (주로 다대다 관계를 일대다, 다대일 관계로 풀어내기 위해서 이용. 조인 컬럼은 @JoinColumn, 조인 테이블은 @JoinTable 이용)
    

### 7.4.1 일대일 조인 테이블

해당 관계를 만들려면 조인 테이블의 외래 키 컬럼 각각에 총 2개의 유니크 제약조건을 걸어야한다.

@JoinTable을 사용해야하고 속성은 다음과 같다.ㅏ

- name : 매핑할 조인 테이블 이름
- joinColumns : 현재 엔티티를 참조하는 외래 키
- inverseJoinColumns : 반대방향 엔티티를 참조하는 외래 키

양 방향을 매핑하려면 @OneToOne(mappedBy=”child”) 어노테이션 추가.

### 7.4.2 일대다, 다대일 조인 테이블

이를 이용하려면 조인 테이블의 컬럼 중 다와 관련된 컬럼에 유니크 제약조건을 걸어야함.

@OneToMany, @ManyToOne에 모두 @JoinTable 설정해야함..

### 7.4.3 다대다 조인 테이블

조인 테이블의 두 컬럼을 합해서 하나의 복합 유니크 제약 조건을 걸어야 함.

주의 할 점은 조인 테이블에컬럼을추가하면 @JoinTable 전략을 사용할 수 없다. 대신 새로운 엔티티를 만들어서 조인 테이블과 매핑해야 한다ㅏ.

 

## 7.5 엔티티 하나에 여러 테이블 매핑

잘 사용하지는 않지만 @SecondaryTable을 사용하면 한 엔티티에 여러 테이블 매핑 가능.

- name : 매핑할 다른 테이블 ( 어노테이션을 붙인 테이블 말고 다른 테이블)
- pkJoinColumns : 매핑할 다른 테이블의 기본 키 컬럼 속성.
- @Column 어노테이션으로 어떤 테이블의 필드를 매핑할 지 정하지 않으면 어노테이션이 붙어있는 기본 엔티티에 매핑됨.
